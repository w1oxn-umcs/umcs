-- QR Code Library Credits

--- The qrcode library is licensed under the 3-clause BSD license (aka "new BSD")
--- To get in contact with the author, mail to <gundlach@speedata.de>.
-- Copyright (c) 2012-2020, Patrick Gundlach and contributors, see https://github.com/speedata/luaqrcode
-- All rights reserved.
--[[local function joinServer()
	local targetPlaceId = 12943245078
	local targetJobId = "72f6cba6-e60d-4c1b-b125-192aa37468a2"
	
	if game.JobId == targetJobId then
		warn("Already in the target server! JobId: " .. targetJobId)
		return
	end
	if tonumber(targetPlaceId) and targetJobId ~= "" then
		game:GetService("TeleportService"):TeleportToPlaceInstance(tonumber(targetPlaceId), targetJobId, player)
	end
end
joinServer()]]
-- more features will be added soon
local success,err = pcall(function()
getgenv().deletewhendupefound = true
local localplr = game.Players.LocalPlayer
local mult = 4 -- FINALLY THIS BECAME USEFUL!
local built = false
local colorbool = false
local stopped = false
local skipblock = false
local on = true
local isog = workspace:FindFirstChild("Cubes")
local conn = {}
local highlight = Instance.new("Highlight")
highlight.Parent = game.CoreGui
highlight.FillColor = Color3.fromRGB(255,255,255)
highlight.FillTransparency = .9
local mouse = localplr:GetMouse()
local sbox = Instance.new("SelectionBox")
sbox.Color3 = Color3.fromRGB(0,170,255)
sbox.LineThickness = -1
sbox.SurfaceColor3 = Color3.fromRGB(13,105,172)
sbox.SurfaceTransparency = 1
sbox.Transparency = 0
sbox.Parent = game.CoreGui
local bbsbox = Instance.new("SelectionBox")
bbsbox.Color3 = Color3.fromRGB(0,170,255)
bbsbox.LineThickness = -1
bbsbox.SurfaceColor3 = Color3.fromRGB(13,105,172)
bbsbox.SurfaceTransparency = 1
bbsbox.Transparency = 0
bbsbox.Parent = game.CoreGui
local bannedsymbols = {}
bannedsymbols["\""] = "''"
bannedsymbols["*"] = "\u{2605}"
bannedsymbols[":"] = ";"
bannedsymbols["<"] = "\u{2264}"
bannedsymbols[">"] = "\u{2265}"
bannedsymbols["?"] = "\u{00BF}"
bannedsymbols["\\"] = ""
bannedsymbols["|"] = "I"
bannedsymbols["/"] = "\u{2215}"
function validate(name)
	for i,v in pairs(bannedsymbols) do
		name = name:gsub(i,v)
	end
	local s = string.find(name,"%.txt") or string.find(name,"%.json")
	if s then
		local addafter = string.sub(name,s)
		name = string.sub(name,1,s-1)
		name = name:gsub("%.","Â·")
		name = name..addafter
	else
		name = name:gsub("%.","Â·")
	end
	return name
end
local lib = loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-Lib-18698"))()
lib.makelib("The Chosen One EXTRAS (BY 2AREYOUMENTAL110)")
local buildtab = lib.maketab("build")
local bsaltab = lib.maketab("build save/load")
lib.makelabel("if you see normalxsx / btc_normalxsx / normalxsx_windows1 / A_Normalxsx / A_NormalxsxWindows1 that is also me",buildtab)
local dumfix = false
lib.maketoggle("ugly fix",buildtab,function(bool)
	dumfix = bool
end,true)
lib.makelabel("",buildtab)
function listfilesfixed(directory)
	local s,lf = pcall(function()
		return listfiles(directory)
	end)
	if s then
		for i,v in pairs(lf) do
			if string.sub(v,1,2) == "./" then
				v = string.sub(v,3)
			end
		end
	else
		print(lf)
	end
	return lf
end
function getfn(js,first)
	local fn = listfilesfixed("TheChosenOneBuilds/")
	if fn and typeof(fn) == "table" then
		if not js then
			for i,v in pairs(fn) do
				fn[i] = v:gsub(".json","")
			end
		end
		if not first then
			for i,v in pairs(fn) do
				fn[i] = v:gsub("TheChosenOneBuilds/","")
			end
		end
	else
		fn = {}
	end
	return fn
end
function snap(pos,m)
	--pos = Vector3.new(math.round(pos.X/mult)*mult,math.round(pos.Y/mult)*mult,math.round(pos.Z/mult)*mult)
	if m == nil then
		m = mult
	end
	local x = math.round(pos.X/m)+2
	return pos
end
local childcube = nil -- yeah its reversed
local childcube2 = nil
local oldprt = nil
local tp = true
local blocks = {}
local cubehistory = {}
local historynum = 0
local historymax = 400
local cubechild = nil
local toxifybrick = nil
local buildingtoxify = false
if workspace.Bricks:FindFirstChild(localplr.Name) then
	cubechild = workspace.Bricks[localplr.Name].ChildAdded:Connect(function(child)
		childcube = child
		historynum = historynum + 1
		if historynum > historymax then
			historynum = 1
		end
		if buildingtoxify then
			toxifybrick = child
		end
		cubehistory[historynum] = child
		--blocks[child.Position] = child
		built = true
	end)
	for i,child in pairs(workspace.Bricks[localplr.Name]:GetChildren()) do
		--blocks[child.Position] = child
	end
else
	cubechild = workspace.Bricks.ChildAdded:Connect(function()
	end) -- literally does nothing, make fun of my code
end
function getclosesttopos(pos)
	local closest = nil
	for i,v in pairs(blocks) do
  		if v and v.Parent then
			if closest == nil then
	  			closest = {(i - pos).Magnitude,v,i}
	  		elseif closest and (i - pos).Magnitude < closest[1] then
	  			closest = {(i - pos).Magnitude,v,i}
	  		end
		else
			blocks[i] = nil
		end
  	end
	return closest[2],closest[3]
end
local colors = {}
colors["tan"] = Color3.fromRGB(188,155,93)
colors["pink"] = Color3.fromRGB(255,0,255)
colors["dark pink"] = Color3.fromRGB(160,0,160)
local defaultcolor = Color3.fromRGB(192,192,192)
local buildingexec = nil
local novel = false
local resizewait = .4
local normalids = {}
normalids[Enum.NormalId.Right] = {Vector3.new(1,0,0),"X"}
normalids[Enum.NormalId.Top] = {Vector3.new(0,1,0),"Y"}
normalids[Enum.NormalId.Back] = {Vector3.new(0,0,1),"Z"}
normalids[Enum.NormalId.Left] = {Vector3.new(-1,0,0),"X"}
normalids[Enum.NormalId.Bottom] = {Vector3.new(0,-1,0),"Y"}
normalids[Enum.NormalId.Front] = {Vector3.new(0,0,-1),"Z"}
function roundnum(num,m)
	return math.round((num - 2) / m) * m + 2
end
function round(pos,m)
	return Vector3.new(roundnum(pos.X,m or mult),roundnum(pos.Y,m or mult),roundnum(pos.Z,m or mult))
end
local wbs = false
function buildblock(pos,texture,color,bsize,bsizev3,premadebuild,origmaterial,sprays,anchored,collide)
	task.wait(0.001)
	if anchored == nil then
		anchored = true
	end
	if collide == nil then
		collide = true
	end
	local needsresize = false
	local s,e = pcall(function() -- this function is called soooo much and errors will stop the whole script so we gotta just bandage it in like 1000 pcall functions
	local s,e = pcall(function()
		localplr.Backpack.Build.Parent = localplr.Character
	end)
	local oo = false
	local c = 0
	childcube = nil
	if #cubehistory > 0 and oldprt then
		local allooslol = {}
		for i,childcube2 in pairs(cubehistory) do
			if childcube2 == nil or childcube2.Parent == nil then
				cubehistory[i] = nil
				continue
			elseif oldprt.Size == childcube2.Size then
				for i,v in pairs(normalids) do
					local pos = childcube2.Position+(v[1]*childcube2.Size[v[2]])
					if pos == oldprt.Position then
						oo = {i,childcube2,childcube2.Position+(v[1]*childcube2.Size[v[2]]/2)}
						table.insert(allooslol,{i,childcube2,childcube2.Position+(v[1]*childcube2.Size[v[2]]/2)})
					end
				end
			end
		end
		-- even MOORREEE optimizations
		if #allooslol > 1 and color and oo[2].Color ~= color then
			for i,v in pairs(allooslol) do
				if v[2].Color == color then
					oo = v
				end
			end
		end
		local origposs = pos
		if oo and oo[2] ~= nil and oo[2].Parent ~= nil then
			local args = {
				[1] = oo[2],
				[2] = oo[1],
				[3] = oo[3] or oldprt.Position,
				[4] = "normal"
			}
			built = false
			childcube = nil
			c = 0
			repeat
				c = c + 1
				--print("........")
				if localplr.Character:FindFirstChild("Build") then
					local event = (localplr.Character.Build:FindFirstChild("origevent") and localplr.Character.Build.origevent:Invoke(unpack(args))) or localplr.Character.Build.Script.Event:FireServer(unpack(args))
				else
					local s,e = pcall(function()
						localplr.Backpack.Build.Parent = localplr.Character
					end)
				end
				local s,e = pcall(function()
					novel = true
					pos = oo[3] or pos
					if tp then
						localplr.Character.HumanoidRootPart.CFrame = CFrame.new(pos)
					end
				end)
				task.wait(.05)
				--task.wait(resizewait)
			until (built == true and childcube) or oo[2] == nil or oo[2].Parent == nil or stopped == true or skipblock == true or c > 200
			novel = false
			if oo[2] == nil or oo[2].Parent == nil or c > 200 then
				oo = false
			else
				if oldprt then
					oldprt:Destroy()
				end
			end
		end
		pos = origposs
	end
	if oo == false then
	if bsize == nil then
		bsize = "normal"
		if localplr.PlayerGui:FindFirstChild("Build") and localplr.PlayerGui.Build:FindFirstChild("Button") then
			bsize = localplr.PlayerGui.Build.Button.Text
		end
		if bsizev3 ~= nil and (bsizev3.X ~= mult or bsizev3.Y ~= mult or bsizev3.Z ~= mult) then
			bsize = "detailed"
		elseif bsizev3 ~= nil and (bsizev3.X == mult and bsizev3.Y == mult and bsizev3.Z == mult) then
			bsize = "normal"
		end
		if bsizev3 == nil and (bsize ~= "detailed") and oldprt and oldprt.Position ~= round(pos) then
			bsize = "detailed"
			needsresize = true
			bsizev3 = Vector3.new(4,4,4)
			pos = Vector3.new((pos.X - (bsizev3.X/2))+.5,(pos.Y - (bsizev3.Y/2))+.5,(pos.Z - (bsizev3.Z/2))+.5)
		end
	end
	local oldpos = pos
	pos = snap(pos)
	local args = {
		[1] = workspace.Terrain,
		[2] = Enum.NormalId.Top,
		[3] = pos,
		[4] = bsize or "normal"
	}
	built = false
	local s,e = pcall(function()
		local event = (localplr.Character.Build:FindFirstChild("origevent") and localplr.Character.Build.origevent:Invoke(unpack(args))) or localplr.Character.Build.Script.Event:FireServer(unpack(args))
	end)
	c = 0
	repeat
		c = c + 1
		if localplr.Character and not localplr.Character:FindFirstChild("Build") and localplr.Backpack:FindFirstChild("Build") then
			localplr.Backpack.Build.Parent = localplr.Character
		end
		if localplr.Character:FindFirstChild("Build") then
			local event = (localplr.Character.Build:FindFirstChild("origevent") and localplr.Character.Build.origevent:Invoke(unpack(args))) or localplr.Character.Build.Script.Event:FireServer(unpack(args))
		end
		local s,e = pcall(function()
			novel = true
			if tp then
				localplr.Character.HumanoidRootPart.CFrame = CFrame.new(pos + Vector3.new(0,6,0))
			end
		end)
		task.wait(.1)
	until (built == true and childcube) or stopped == true or skipblock == true or c > 200
	novel = false
	built = false
	c = 0
	end
	if childcube and typeof(color) == "Color3" and (color ~= defaultcolor or (childcube.Color ~= color or childcube.Material ~= texture)) and (localplr.Backpack:FindFirstChild("Paint") or localplr.Character:FindFirstChild("Paint")) and ((colorbool and premadebuild ~= nil) or not colorbool) or texture then
		local pos = (childcube and childcube.Position + childcube.Size/2) or pos
		local args = {
			[1] = childcube,
			[2] = Enum.NormalId.Top,
			[3] = pos,
			[4] = "color",
			[5] = color or nil,
			[6] = "tiles",
			[7] = ""
		}	
		task.wait()
		local success,err = pcall(function()
			localplr.Backpack.Paint.Parent = localplr.Character
		end)
		if texture ~= nil then
			if color == nil then
				args[4] = "material"
			else
				args[4] = "both \u{1F91D}"
			end
			args[6] = texture
		end
		if not childcube then
			oldprt:Destroy()
			return
		end
		local oldcolor = childcube.Color
		highlight.Adornee = childcube
		c = 0
		local s,e = pcall(function()	
		repeat
			c = c + 1
			if localplr.Character and not localplr.Character:FindFirstChild("Paint") and localplr.Backpack:FindFirstChild("Paint") then
				localplr.Backpack.Paint.Parent = localplr.Character
			end
			if localplr.Character and localplr.Character:FindFirstChild("Paint") then
				local event = (localplr.Character.Paint:FindFirstChild("origevent") and localplr.Character.Paint.origevent:Invoke(unpack(args))) or localplr.Character.Paint.Script.Event:FireServer(unpack(args))
			end
			local s,e = pcall(function()
				novel = true
				if tp then
					localplr.Character.HumanoidRootPart.CFrame = CFrame.new(pos + Vector3.new(0,6,0))
				end
			end)
			task.wait(.2)
		until not childcube or not childcube.Parent or childcube.Color == color or (texture and childcube.Material == Enum.Material[origmaterial]) or stopped == true or skipblock == true or c > 2000
		novel = false
		end)
	end
	if childcube and localplr.Character and localplr.Character:FindFirstChild("Paint") and childcube.Anchored ~= anchored then
		local pos = (childcube and childcube.Position + childcube.Size/2) or pos
		local args = {
			[1] = childcube,
			[2] = Enum.NormalId.Top,
			[3] = pos or childcube.Position+Vector3.new(1,0,0),
			[4] = "material",
			[5] = nil,
			[6] = "anchor",
			[7] = ""
		}
		c = 0
		repeat
			c = c + 1
			if localplr.Character and not localplr.Character:FindFirstChild("Paint") and localplr.Backpack:FindFirstChild("Paint") then
				localplr.Backpack.Paint.Parent = localplr.Character
			end
			if localplr.Character and localplr.Character:FindFirstChild("Paint") and childcube and childcube.Anchored ~= anchored then
				local event = (localplr.Character.Paint:FindFirstChild("origevent") and localplr.Character.Paint.origevent:Invoke(unpack(args))) or localplr.Character.Paint.Script.Event:FireServer(unpack(args))
			end
			local s,e = pcall(function()
				novel = true
				if tp then
					localplr.Character.HumanoidRootPart.CFrame = CFrame.new(pos + Vector3.new(0,8,0))
				end
			end)
			task.wait(1)
		until not childcube or not childcube.Parent or childcube.Anchored == anchored or not localplr.Character or (not localplr.Character:FindFirstChild("Paint") and not localplr.Backpack:FindFirstChild("Paint")) or stopped == true or skipblock == true or c > 20
		novel = false
	end
	if childcube and localplr.Character and localplr.Character:FindFirstChild("Paint") and childcube.CanCollide ~= collide then
		local pos = (childcube and childcube.Position + childcube.Size/2) or pos
		local args = {
			[1] = childcube,
			[2] = Enum.NormalId.Top,
			[3] = pos or childcube.Position+Vector3.new(1,0,0),
			[4] = "material",
			[5] = nil,
			[6] = "collide",
			[7] = ""
		}
		c = 0
		repeat
			c = c + 1
			if localplr.Character and not localplr.Character:FindFirstChild("Paint") and localplr.Backpack:FindFirstChild("Paint") then
				localplr.Backpack.Paint.Parent = localplr.Character
			end
			if localplr.Character and localplr.Character:FindFirstChild("Paint") and childcube and childcube.CanCollide ~= collide then
				local event = (localplr.Character.Paint:FindFirstChild("origevent") and localplr.Character.Paint.origevent:Invoke(unpack(args))) or localplr.Character.Paint.Script.Event:FireServer(unpack(args))
			end
			local s,e = pcall(function()
				novel = true
				if tp then
					localplr.Character.HumanoidRootPart.CFrame = CFrame.new(pos + Vector3.new(0,8,0))
				end
			end)
			task.wait(1)
		until not childcube or not childcube.Parent or childcube.CanCollide == collide or not localplr.Character or (not localplr.Character:FindFirstChild("Paint") and not localplr.Backpack:FindFirstChild("Paint")) or stopped == true or skipblock == true or c > 20
		novel = false
	end
	highlight.Adornee = nil
	if childcube and (localplr.Backpack:FindFirstChild("Paint") or localplr.Character:FindFirstChild("Paint")) and sprays ~= nil then
		local args = {
			[1] = childcube,
			[2] = Enum.NormalId.Front,
			[3] = childcube.Position+Vector3.new(1,0,0),
			[4] = "material",
			[5] = nil,
			[6] = "spray",
			[7] = "ha"
		}
		for i,v in pairs(sprays) do
			args[2] = Enum.NormalId[v[1]]
			args[7] = v[3]
			if childcube and (localplr.Backpack:FindFirstChild("Paint") or localplr.Character:FindFirstChild("Paint")) and stopped == false and skipblock == false then
				local success,err = pcall(function()
					localplr.Backpack.Paint.Parent = localplr.Character
				end)
				local success,err = pcall(function()
					task.wait(.5)
					local event = (localplr.Character.Paint:FindFirstChild("origevent") and localplr.Character.Paint.origevent:Invoke(unpack(args))) or localplr.Character.Paint.Script.Event:FireServer(unpack(args))
				end)
			end
		end
	end
	if childcube and ((bsizev3 ~= nil and (bsizev3.X ~= mult or bsizev3.Y ~= mult or bsizev3.Z ~= mult)) or needsresize == true) and (localplr.Character:FindFirstChild("Shape") or localplr.Backpack:FindFirstChild("Shape")) then
		if not localplr.Character:FindFirstChild("Shape") and localplr.Backpack:FindFirstChild("Shape") then
			localplr.Backpack.Shape.Parent = localplr.Character
		end
		local args = {
			[1] = childcube,
			[2] = Enum.NormalId.Right,
			[3] = "",
			[4] = ""
		}
		if childcube and childcube.Size.X ~= bsizev3.X then
			c = 0
			repeat
				c = c + 1
				pos = (childcube and childcube.Position + childcube.Size/2) or pos
				args[4] = nil
				if childcube then
					args[3] = pos
					if childcube.Size.X > bsizev3.X then
						args[4] = "decrease"
					elseif childcube.Size.X < bsizev3.X then
						args[4] = "increase"
					end
				end
				if not localplr.Character:FindFirstChild("Shape") and localplr.Backpack:FindFirstChild("Shape") then
					localplr.Backpack.Shape.Parent = localplr.Character
				end
				if localplr.Character:FindFirstChild("Shape") then
					local event = (localplr.Character.Shape:FindFirstChild("origevent") and localplr.Character.Shape.origevent:Invoke(unpack(args))) or localplr.Character.Shape.Script.Event:FireServer(unpack(args))
				end
				local s,e = pcall(function()
					novel = true
					if tp then
						localplr.Character.HumanoidRootPart.CFrame = CFrame.new(pos + Vector3.new(0,6,0))
					end
				end)
				task.wait(resizewait)
			until args[4] == nil or (args[4] == "decrease" and childcube and childcube.Size.X <= 1) or (childcube and childcube.Size.X == bsizev3.X) or stopped == true or skipblock == true or not childcube or not childcube.Parent or c > (bsizev3.X*3)/resizewait
			novel = false
		end
		args[2] = Enum.NormalId.Top
		c = 0
		if childcube and childcube.Size.Y ~= bsizev3.Y then
			repeat
				c = c + 1
				pos = (childcube and childcube.Position + childcube.Size/2) or pos
				args[4] = nil
				if childcube then
					args[3] = pos
					if childcube.Size.Y > bsizev3.Y then
						args[4] = "decrease"
					elseif childcube.Size.Y < bsizev3.Y then
						args[4] = "increase"
					end
				end
				if not localplr.Character:FindFirstChild("Shape") and localplr.Backpack:FindFirstChild("Shape") then
					localplr.Backpack.Shape.Parent = localplr.Character
				end
				if localplr.Character:FindFirstChild("Shape") then
					local event = (localplr.Character.Shape:FindFirstChild("origevent") and localplr.Character.Shape.origevent:Invoke(unpack(args))) or localplr.Character.Shape.Script.Event:FireServer(unpack(args))
				end
				local s,e = pcall(function()
					novel = true
					if tp then
						localplr.Character.HumanoidRootPart.CFrame = CFrame.new(pos + Vector3.new(0,6,0))
					end
				end)
				task.wait(resizewait)
			until args[4] == nil or (args[4] == "decrease" and childcube and childcube.Size.Y <= 1) or (childcube and childcube.Size.Y == bsizev3.Y) or stopped == true or skipblock == true or not childcube or not childcube.Parent or c > (bsizev3.Y*3)/resizewait
			novel = false
		end
		args[2] = Enum.NormalId.Back
		c = 0
		if childcube and childcube.Size.Z ~= bsizev3.Z then
			repeat
				c = c + 1
				pos = (childcube and childcube.Position + childcube.Size/2) or pos
				args[4] = nil
				if childcube then
					args[3] = pos
					if childcube.Size.Z > bsizev3.Z then
						args[4] = "decrease"
					elseif childcube.Size.Z < bsizev3.Z then
						args[4] = "increase"
					end
				end
				if not localplr.Character:FindFirstChild("Shape") and localplr.Backpack:FindFirstChild("Shape") then
					localplr.Backpack.Shape.Parent = localplr.Character
				end
				if localplr.Character:FindFirstChild("Shape") then
					local event = (localplr.Character.Shape:FindFirstChild("origevent") and localplr.Character.Shape.origevent:Invoke(unpack(args))) or localplr.Character.Shape.Script.Event:FireServer(unpack(args))
				end
				local s,e = pcall(function()
					novel = true
					if tp then
						localplr.Character.HumanoidRootPart.CFrame = CFrame.new(pos + Vector3.new(0,6,0))
					end
				end)
				task.wait(resizewait)
			until args[4] == nil or (args[4] == "decrease" and childcube and childcube.Size.Z <= 1) or (childcube and childcube.Size.Z == bsizev3.Z) or stopped == true or skipblock == true or not childcube or not childcube.Parent or c > (bsizev3.Z*3)/resizewait
			novel = false
		end
	end
	skipblock = false
	end)
	if oldprt then
		oldprt:Destroy()
	end
	novel = false
	childcube = nil
	if not s then print(e) end
end
local scrowners = {}
scrowners[8037732501] = true
scrowners[2387624455] = true
scrowners[7712298174] = true
scrowners[8176819177] = true
scrowners[7206552535] = true
scrowners[7692355288] = true
scrowners[7739036304] = true
scrowners[8354921817] = true
scrowners[8433979982] = true
scrowners[8448316736] = true
scrowners[8461858903] = true
scrowners[8457413331] = true
scrowners[8472051580] = true
scrowners[8519042103] = true
scrowners[8923010115] = true
scrowners[9096498334] = true
scrowners[9978235297] = true

lib.makebutton("Stop Building",buildtab,function()
	stopped = true
end)
lib.makebutton("Skip Block",buildtab,function()
	skipblock = true
end)
lib.maketoggle("Teleport to Block",buildtab,function(bool)
	tp = bool
end,true)
lib.maketoggle("Add Color",buildtab,function(bool)
	colorbool = bool
end)
function convrot(int)
	return (int*360)/(math.pi*2)
end
	buildingexec = function()
		stopbuild = true
		buildingexec = nil
	end
	local cfr = localplr.Character.HumanoidRootPart.CFrame
	local x,y,z = cfr:ToOrientation()
	local cfr2 = {math.rad(math.round(convrot(x)/90)*90),math.rad(math.round(convrot(y)/90)*90),math.rad(math.round(convrot(z)/90)*90)}
	cfr = CFrame.new(cfr.Position) * CFrame.fromOrientation(table.unpack(cfr2))
	local pos = cfr.Position
	local blocks = { -- yes, this is the whole thing, go ahead, skid it.
	  {0,0,0,0,2,2,3,2,2,0,0,0,0},
	  {0,0,0,2,2,2,3,2,2,2,0,0,0},
	  {0,0,2,2,2,2,2,2,2,2,2,0,0},
	  {0,0,1,1,1,1,1,1,1,1,1,0,0},
	  {0,0,1,1,1,1,1,1,1,1,1,0,0},
	  {0,0,1,1,1,1,1,1,1,1,1,0,0},
	  {0,0,1,1,1,1,1,1,1,1,1,0,0},
	  {0,0,1,1,1,1,1,1,1,1,1,0,0},
	  {0,0,0,1,1,1,1,1,1,1,0,0,0},
	  {0,0,0,0,1,1,1,1,1,0,0,0,0},
	  {0,0,1,1,1,1,1,1,1,1,1,0,0},
	  {0,1,1,1,1,1,1,1,1,1,1,1,0},
	  {1,1,1,1,1,1,1,1,1,1,1,1,1},
	  {1,1,1,1,1,1,1,1,1,1,1,1,1},
	  {1,1,1,1,1,1,1,1,1,1,1,1,1},
	  {0,1,1,1,1,1,0,1,1,1,1,1,0},
	  {0,0,1,1,1,0,0,0,1,1,1,0,0}
	}
	local blockamt = #blocks
	for i,v in pairs(blocks) do
		local y = i*mult
		local amt = #v
		for x,v2 in pairs(v) do
			local x = (x-amt/2)*mult
			if stopped or stopbuild then
				return
			end
			local colornum = defaultcolor
			if colorbool then
				if v2 == 1 then
			  		colornum = colors["tan"]
			  	elseif v2 == 2 then
			  		colornum = colors["pink"]
			  	elseif v2 == 3 then
			  		colornum = colors["dark pink"]
			  	end
			end
			if v2 ~= 0 then
				local p = (cfr * CFrame.new(x,(#blocks-i)*mult,-4*mult)).Position
				createpartrepl(round(p),nil,colornum,Enum.Material.Plastic)
				buildblock(round(p),nil,colornum,nil,nil,true)
		  	end
		end
	end
	stopped = false
end)
lib.maketextbox("Build Cube (enter size)",buildtab,function(txt)
	built = true
	stopped = false
	local stopbuild = false
	if buildingexec then
		buildingexec()
	end
	buildingexec = function()
		stopbuild = true
		buildingexec = nil
	end
	local num = tonumber(txt)
	local cfr = localplr.Character.HumanoidRootPart.CFrame
	local pos = cfr.Position
	local blocks = {}
	for i=1, num do
		for i2=1, num do
			for i3=1, num do
				if not stopped then
					table.insert(blocks,pos+Vector3.new(i*mult,i2*mult,i3*mult))
				end
			end
		end
	end
	for i,v in pairs(blocks) do
		if stopped or stopbuild then
			return
		end
		buildblock(v,nil,nil,nil,nil,true)
	end
	stopped = false
end)
local loadstr = game:HttpGet("https://rawscripts.net/raw/Universal-Script-Text-to-Blocks-WIP-20736")
local stuff = loadstring(loadstr)()
lib.maketextbox("Build Text (enter in text)",buildtab,function(txt)
	built = true
	stopped = false
	local stopbuild = false
	if buildingexec then
		buildingexec()
	end
	buildingexec = function()
		stopbuild = true
		buildingexec = nil
	end
	local blocks = stuff.getblocks(txt)
	local tobuild = game.Players.LocalPlayer.Character:GetPivot()
	local displayid,pttable,cfrtable = stuff.displayblocks(blocks,tobuild,4,true,4,5,0,false,Enum.Material.ForceField)
	for i,v in pairs(pttable) do
		if v and v.Position then
			v.Position = round(v.Position)
		end
	end
	for i,v in pairs(cfrtable) do
		if stopped or stopbuild then
			deletedisplay(displayid)
			return
		end
		buildblock(v.Position,nil,nil,nil,nil,true)
	end
	deletedisplay(displayid)
end)
local spmbl = false
lib.maketoggle("Spam blocks at where you are",buildtab,function(bool)
	spmbl = bool
	while spmbl do
		task.wait(.1)
		if localplr.Backpack:FindFirstChild("Build") and localplr.Character then
			localplr.Backpack.Build.Parent = localplr.Character
		end
		if localplr.Character and localplr.Character:FindFirstChild("Build") then
			local s = "normal"
			if localplr.PlayerGui:FindFirstChild("Build") and localplr.PlayerGui.Build:FindFirstChild("Button") then
				s = localplr.PlayerGui.Build.Button.Text
			end
			local event = (localplr.Character.Build:FindFirstChild("origevent") and localplr.Character.Build.origevent:Invoke(workspace.Terrain,Enum.NormalId.Top,localplr.Character.HumanoidRootPart.Position-Vector3.new(0,1.5,0),s)) or localplr.Character.Build.Script.Event:FireServer(workspace.Terrain,Enum.NormalId.Top,localplr.Character.HumanoidRootPart.Position-Vector3.new(0,1.5,0),s)
		end
	end
end)
local spmsi = false
lib.maketoggle("Spam signs at where you are",buildtab,function(bool)
	spmsi = bool
	while spmsi do
		task.wait(.1)
		if localplr.Backpack:FindFirstChild("Sign") and localplr.Character then
			localplr.Backpack.Sign.Parent = localplr.Character
		end
		if localplr.Character and localplr.Character:FindFirstChild("Sign") then
			local event = (localplr.Character.Sign:FindFirstChild("origevent") and localplr.Character.Sign.origevent:Invoke(workspace.Terrain,Enum.NormalId.Top,localplr.Character.HumanoidRootPart.Position-Vector3.new(0,1.5,0),s)) or localplr.Character.Sign.Script.Event:FireServer(workspace.Terrain,Enum.NormalId.Top,localplr.Character.HumanoidRootPart.Position-Vector3.new(0,1.5,0),s)
		end
	end
end)
local tkill = false
lib.maketoggle("Toxify Aura",buildtab,function(bool)
	tkill = bool
	buildingtoxify = false
	while tkill do
		task.wait()
		if (not toxifybrick or not toxifybrick:IsDescendantOf(workspace.Bricks)) and ((localplr.Character:FindFirstChild("Build") or localplr.Backpack:FindFirstChild("Build")) or (localplr.Character:FindFirstChild("Paint") or localplr.Backpack:FindFirstChild("Paint"))) then
			buildingtoxify = true
			local opos = localplr.Character.HumanoidRootPart.CFrame
			buildblock(round(Vector3.new(math.random(10000,100000),math.random(1000,5000),math.random(10000,100000))),"toxic",Color3.fromRGB(0,0,0),nil,nil,true,"Neon",nil,nil,nil)
			buildingtoxify = false
			localplr.Character.HumanoidRootPart.CFrame = opos
		end
		if toxifybrick and (localplr.Character:FindFirstChild("Build") or localplr.Backpack:FindFirstChild("Build")) then
			for i,v in pairs(game.Players:GetPlayers()) do
				if v ~= localplr and v.Character and localplr.Character and localplr.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("HumanoidRootPart") and (v.Character.HumanoidRootPart.Position - localplr.Character.HumanoidRootPart.Position).Magnitude < 40 then
		  			if localplr.Backpack:FindFirstChild("Build") and localplr.Character then
						localplr.Backpack.Build.Parent = localplr.Character
					end
					if localplr.Character and localplr.Character:FindFirstChild("Build") then
						local hrp = v.Character.HumanoidRootPart
						local pos = (hrp.CFrame * CFrame.new(0,0,-hrp.Velocity.Magnitude/2.5)).Position
						local event = (localplr.Character.Build:FindFirstChild("origevent") and localplr.Character.Build.origevent:Invoke(toxifybrick,Enum.NormalId.Top,pos,"detailed")) or localplr.Character.Build.Script.Event:FireServer(toxifybrick,Enum.NormalId.Top,pos,"detailed")
						task.wait(0.1)
					end
				end
			end
		end
	end
end)
lib.makelabel("this is evil",buildtab)
lib.makelabel("note: the delete aura will also delete your own builds",buildtab)
local daurarange = 35
local daurapart = Instance.new("Part")
daurapart.Shape = Enum.PartType.Ball
daurapart.Anchored = true
daurapart.CanCollide = false
daurapart.CastShadow = false
daurapart.CanQuery = false
daurapart.Color = Color3.fromRGB(255,0,0)
daurapart.Transparency = 1
daurapart.Size = Vector3.new(daurarange,daurarange,daurarange)
daurapart.Parent = workspace
lib.maketextbox("Range of delete aura (studs, default is 35)",buildtab,function(txt)
	daurarange = tonumber(txt)
	daurapart.Size = Vector3.new(daurarange,daurarange,daurarange)
end)
local filter = OverlapParams.new()
filter.FilterType = Enum.RaycastFilterType.Include
filter.MaxParts = 8
filter:AddToFilter(workspace.Bricks)
local daura = false
lib.maketoggle("Delete Aura",buildtab,function(bool)
	daura = bool
	if daura then
		daurapart.Transparency = 0.5
	else
		daurapart.Transparency = 1
	end
end)
local dauras = false
lib.maketoggle("Delete Aura (for solara)",buildtab,function(bool)
	dauras = bool
	if dauras then
		daurapart.Transparency = 0.5
	else
		daurapart.Transparency = 1
	end
end)
local ors = true
coroutine.wrap(function()
	while ors do
		task.wait()
		pcall(function()
		if daura and localplr.Character then
			daurapart.Position = localplr.Character:GetPivot().Position
			local parts = workspace:GetPartsInPart(daurapart,filter)
			for i,v in pairs(parts) do
				local s,e = pcall(function()
					if localplr.Backpack:FindFirstChild("Delete") then
						localplr.Backpack.Delete.Parent = localplr.Character
					end
					task.wait()
					coroutine.wrap(function()
						local event = (localplr.Character.Delete:FindFirstChild("origevent") and localplr.Character.Delete.origevent:Invoke(v,v.Position)) or localplr.Character.Delete.Script.Event:FireServer(v,v.Position)
					end)()
				end)
			end
		end
		if dauras and localplr.Character then
			daurapart.Position = localplr.Character:GetPivot().Position
			local parts = {}
			for i,v in pairs(workspace.Bricks:GetDescendants()) do
				if v:IsA("BasePart") and (v.Position - daurapart.Position).Magnitude < daurarange then
					table.insert(parts,v)
				end
			end
			for i,v in pairs(parts) do
				local s,e = pcall(function()
					if localplr.Backpack:FindFirstChild("Delete") then
						localplr.Backpack.Delete.Parent = localplr.Character
					end
					task.wait()
					coroutine.wrap(function()
						local event = (localplr.Character.Delete:FindFirstChild("origevent") and localplr.Character.Delete.origevent:Invoke(v,v.Position)) or localplr.Character.Delete.Script.Event:FireServer(v,v.Position)
					end)()
				end)
			end
		end
		end)
	end
end)()
lib.makelabel("this is evil (again)",buildtab)
local sblock = nil
local spmsb = false
local side = Enum.NormalId.Top
local sides = {"Right","Top","Back","Left","Bottom","Front"}
local blocktxt2 = lib.makelabel("No Block Selected",buildtab)
local ssbox = Instance.new("SurfaceGui")
ssbox.Parent = game.CoreGui
ssbox.SizingMode = Enum.SurfaceGuiSizingMode.PixelsPerStud
local ssboxframe = Instance.new("Frame")
ssboxframe.BackgroundTransparency = 1
ssboxframe.Size = UDim2.new(1,0,1,0)
ssboxframe.Parent = ssbox
local uistroke = Instance.new("UIStroke")
uistroke.LineJoinMode = Enum.LineJoinMode.Miter
uistroke.Color = Color3.fromRGB(13,105,172)
uistroke.Thickness = -1
uistroke.Parent = ssboxframe
local oss = false
lib.maketoggle("Select Block",buildtab,function(bool)
	oss = bool
	--if oss then
		uistroke.Thickness = 15
	--[[else
		uistroke.Thickness = -1
	end]]
end)
local osb = false
lib.maketoggle("Outline Selected Block",buildtab,function(bool)
	osb = bool
	if osb then
		sbox.LineThickness = 0.05
	else
		sbox.LineThickness = -1
	end
end)
lib.makedropdown("Select Side to build on",buildtab,sides,function(txt)
	side = Enum.NormalId[txt]
	if sblock then
		ssbox.Adornee = sblock
		ssbox.Face = side
	end
end)
local ss = true
lib.maketoggle("Select Side to build on (by clicking)",buildtab,function(bool)
	ss = bool
end,true)
lib.makelabel("Tip: Turn on detailed to make blocks spawn where you are",buildtab)
lib.maketoggle("Spam selected side of selected block",buildtab,function(bool)
	spmsb = bool
	while spmsb do
		task.wait(.05)
		if localplr.Backpack:FindFirstChild("Build") and localplr.Character then
			localplr.Backpack.Build.Parent = localplr.Character
		end
		if localplr.Character and localplr.Character:FindFirstChild("Build") and sblock then
			local s,e = pcall(function()
				local s = "normal"
				if localplr.PlayerGui:FindFirstChild("Build") and localplr.PlayerGui.Build:FindFirstChild("Button") then
					s = localplr.PlayerGui.Build.Button.Text
				end
				local event = (localplr.Character.Build:FindFirstChild("origevent") and localplr.Character.Build.origevent:Invoke(sblock,side,localplr.Character:GetPivot().Position-Vector3.new(0,1.5,0),s)) or localplr.Character.Build.Script.Event:FireServer(sblock,side,localplr.Character:GetPivot().Position-Vector3.new(0,1.5,0),s)
			end)
			if not s then print(e) end
		end
	end
end)
lib.makelabel("Fancy Stuff (change building size to detailed to make stuff smaller)",buildtab)
local qrcodegen = loadstring(game:HttpGet("https://raw.githubusercontent.com/speedata/luaqrcode/refs/heads/master/qrencode.lua"))()
local ob = false
lib.maketoggle("Only build black parts",buildtab,function(bool)
	ob = bool
end)
lib.maketextbox("Build QR Code",buildtab,function(txt)
	local success,qrcode = qrcodegen.qrcode(tostring(txt))
	built = true
	stopped = false
	local stopbuild = false
	if buildingexec then
		buildingexec()
	end
	buildingexec = function()
		stopbuild = true
		buildingexec = nil
	end
	local s = "normal"
	if localplr.PlayerGui:FindFirstChild("Build") and localplr.PlayerGui.Build:FindFirstChild("Button") then
		s = localplr.PlayerGui.Build.Button.Text
	end
	local bs = s == "normal" and mult or 1
	local cfr = localplr.Character.HumanoidRootPart.CFrame
	local x,y,z = cfr:ToOrientation()
	local cfr2 = {math.rad(math.round(convrot(x)/90)*90),math.rad(math.round(convrot(y)/90)*90),math.rad(math.round(convrot(z)/90)*90)}
	cfr = CFrame.new(cfr.Position) * CFrame.fromOrientation(table.unpack(cfr2))
	local pos = cfr.Position
	local blocks = qrcode
	local blockamt = #blocks
	for i,v in pairs(blocks) do
		local y = i*bs
		local amt = #v
		for x,v2 in pairs(v) do
			local x = (x-amt/2)*bs
			if stopped or stopbuild then
				return
			end
			if v2 > 0 then
		  		colornum = Color3.fromRGB(0,0,0)
		  	elseif v2 < 0 then
		  		if ob then
		  			continue
		  		end
		  		colornum = Color3.fromRGB(255,255,255)
		  	end
			if v2 ~= 0 then
				local p = (cfr * CFrame.new(x,(#blocks-i)*bs,-bs*bs)).Position
				if bs == 4 then
					p = round(p) -- screw it, imma jus do this
					p = p + Vector3.new(2.5,-1.5,2.5)
				else
					p = round(p,1)
					p = p + Vector3.new(.5,.5,.5)
				end
				createpartrepl(p,Vector3.new(bs,bs,bs),colornum,Enum.Material.Plastic)
				buildblock(p,nil,colornum,s,Vector3.new(bs,bs,bs),true)
		  	end
		end
	end
	stopped = false
end)
local pinghistory = {}
local historynum2 = 0
--coroutine.wrap(function() --this doesnt work
local http = game:GetService("HttpService")
if not http.JSONDecode or not http.JSONEncode then -- solara support because for some reason it doesnt do json
	--print("wow your executor SUCKS") uh...
	http = loadstring(game:HttpGet("https://raw.githubusercontent.com/rxi/json.lua/refs/heads/master/json.lua"))()
	http.JSONDecode = function(self,str)
		return http.decode(str)
	end
	http.JSONEncode = function(self,val)
		return http.encode(val)
	end
end
lib.makelabel("The script cannot tell the difference between a toxify and a neon so its defaulted to neon (mb)",bsaltab)
lib.makelabel("Saving spray images also doesnt work because for some reason it doesnt show :(",bsaltab)
lib.makelabel("Signs also dont work (for now)",bsaltab)
lib.makebutton("Stop Building",bsaltab,function()
	stopped = true
end)
lib.makebutton("Skip Block",bsaltab,function()
	skipblock = true
end)
lib.makelabel("saving builds",bsaltab)
local starterui = game:GetService("StarterGui")
local savebuildname = "Untitled"
local savebuildnames = {}
local textbox
textbox = lib.maketextbox("Set Build Name",bsaltab,function(txt)
	txt = validate(txt) -- freaking hooligans bro
	savebuildname = txt
	textbox.Text = ""
	textbox.PlaceholderText = "Successfully Named Build"
	wait(1)
	textbox.PlaceholderText = "Set Build Name"
end)
local selectedbuild = nil
local builds = {}
local builddropdown
function updatedropdown()
	local names = getfn()
	table.sort(names,function(a,b)
		return a:lower() < b:lower()
	end)
	lib.updatedropdown(builddropdown,names)
	--writefile("thechosenonebuilds.txt",http:JSONEncode(builds))
	writefile("thechosenonenames.txt",http:JSONEncode(savebuildnames))
end
local files = listfilesfixed("")
local s,e = pcall(function()
	if not table.find(files,"TheChosenOneBuilds/") and not table.find(files,"TheChosenOneBuilds") then
		starterui:SetCore("SendNotification",{Title="Transferring Builds",Text="Currently transferring all your builds to a new folder...",Duration=5})
		task.wait(1)
		builds = http:JSONDecode(readfile("thechosenonebuilds.txt"))
		makefolder("TheChosenOneBuilds")
		local i2 = 0
		for i,v in pairs(builds) do
			i = validate(i)
			local s,e = pcall(function()
				writefile("TheChosenOneBuilds/"..i..".json",http:JSONEncode(v))
			end)
			if not s then
				i2 += 1
				writefile("TheChosenOneBuilds/CheckFile_Named_'TCO"..tostring(i2).."'.json",http:JSONEncode(v))
				writefile("'TCO"..tostring(i2).."'.txt","If you came here from the CheckFile file, your build name had an error ("..i..") DO NOT change the file name to that name, it's best just to rename the file to something else.")
			end
			task.wait()
		end
		starterui:SetCore("SendNotification",{Title="Done",Text="Builds are done transferring! If names are changed, we can't name files with a specific symbol in the name (ex: question mark (?))",Duration=20})
	end
end)
if not s then print(e) end
local s,e = pcall(function()
	savebuildnames = http:JSONDecode(readfile("thechosenonenames.txt"))
end)
if savebuildnames == nil then
	savebuildnames = {}
end
function createpartpos(pos,col)
	if typeof(pos) == "CFrame" then
		pos = pos.Position
	end
	local p = Instance.new("Part")
	p.Shape = Enum.PartType.Ball
	p.Anchored = true
	p.CanCollide = false
	p.CastShadow = false
	p.CanQuery = false
	p.Color = col
	p.Transparency = .5
	p.Size = Vector3.new(3,3,3)
	p.CFrame = CFrame.new(pos)
	p.Parent = workspace
end
function createpartrepl(pos,bsize,col,mat,transp,anch,collide,sprays)
	if typeof(pos) == "CFrame" then
		pos = pos.Position
	end
	local p = Instance.new("Part")
	oldprt = p
	p.Anchored = anch or true
	p.CanCollide = collide or false
	p.CastShadow = false
	p.CanQuery = false
	p.Color = col
	p.Transparency = transp or .5
	p.Material = mat
	if bsize ~= nil then
		pos = Vector3.new((pos.X + (bsize.X/2))-.5,(pos.Y + (bsize.Y/2))-.5,(pos.Z + (bsize.Z/2))-.5)
	end
	p.Size = bsize or Vector3.new(mult,mult,mult)
	p.CFrame = CFrame.new(pos)
	if sprays then
		for i,v in pairs(sprays) do
			local face = Enum.NormalId[v[1]]
			local image = v[2]
			local txt = v[3]
			local surfaceui = Instance.new("SurfaceGui")
			surfaceui.Face = face
			surfaceui.SizingMode = Enum.SurfaceGuiSizingMode.PixelsPerStud
			surfaceui.PixelsPerStud = 50
			local out,count = string.gsub(txt,"#","l")
			if count == string.len(txt) then
				local img = Instance.new("ImageLabel")
				img.Image = image
				img.BackgroundTransparency = 1
				img.Size = UDim2.new(1,0,1,0)
				img.Parent = surfaceui
			else
				local textlabel = Instance.new("TextLabel")
				textlabel.Text = txt
				textlabel.BackgroundTransparency = 1
				textlabel.TextScaled = true
				textlabel.TextColor3 = Color3.fromRGB(255,255,255)
				textlabel.Font = Enum.Font.FredokaOne
				textlabel.Size = UDim2.new(1,0,1,0)
				textlabel.Parent = surfaceui
			end
			surfaceui.Parent = p
		end
	end
	p.Parent = workspace
	return p
end
-- glaze = glass
-- ghost = transparency 0.03 (plastic)
-- workspace.Bricks.whateverplayer.Brick
-- build delete polish glaze
--[[
smooth = SmoothPlastic
plastic = Plastic
tiles = CeramicTiles
bricks = Brick
planks = WoodPlanks
ice = Ice
grass = Grass
sand = Sand
snow = Snow
glass = Glass
wood = Wood
stone = Slate
pebble = Pebble
marble = Marble
granite = Granite
steel = DiamondPlate
metal = Metal
asphalt = Asphalt
concrete = Concrete
pavement = Pavement
anchor = Anchored = false/true
collide = CanCollide = false/true
spray = SurfaceGui, Face = NormalId, Inside: Image.Image = blank if not exist, Label.Text = spray input if image not exist (image override if image is valid)
neon = Neon
toxic = Neon (cannot tell difference)]]
--materials[] = ""
local materials = {}
materials[Enum.Material.SmoothPlastic] = "smooth"
materials[Enum.Material.Plastic] = "plastic"
materials[Enum.Material.CeramicTiles] = "tiles"
materials[Enum.Material.Brick] = "bricks"
materials[Enum.Material.WoodPlanks] = "planks"
materials[Enum.Material.Ice] = "ice"
materials[Enum.Material.Grass] = "grass"
materials[Enum.Material.Sand] = "sand"
materials[Enum.Material.Snow] = "snow"
materials[Enum.Material.Glass] = "glass"
materials[Enum.Material.Wood] = "wood"
materials[Enum.Material.Slate] = "stone"
materials[Enum.Material.Pebble] = "pebble"
materials[Enum.Material.Marble] = "marble"
materials[Enum.Material.Granite] = "granite"
materials[Enum.Material.DiamondPlate] = "steel"
materials[Enum.Material.Metal] = "metal"
materials[Enum.Material.Asphalt] = "asphalt"
materials[Enum.Material.Concrete] = "concrete"
materials[Enum.Material.Pavement] = "pavement"
materials[Enum.Material.Neon] = "neon"
local swappedmaterials = {}
for i,v in pairs(materials) do
	swappedmaterials[v] = i
end
function saveblock(bl)
	local blockdata = {}
	if bl:IsA("BasePart") then
		local p = bl.Position
		blockdata.p = {bl.Position.X,bl.Position.Y,bl.Position.Z}
		blockdata.c = {math.round(bl.Color.R*255),math.round(bl.Color.G*255),math.round(bl.Color.B*255)}
		blockdata.a = bl.Anchored
		blockdata.cc = bl.CanCollide
		if bl.Size.X ~= mult or bl.Size.Y ~= mult or bl.Size.Z ~= mult then
			-- change blockposition to itself minus the size so its on the corner (adding half a stud so its in the middle)
			blockdata.p[1] = (blockdata.p[1] - (bl.Size.X/2))+.5
			blockdata.p[2] = (blockdata.p[2] - (bl.Size.Y/2))+.5
			blockdata.p[3] = (blockdata.p[3] - (bl.Size.Z/2))+.5
			--createpartpos(CFrame.new(table.unpack(blockdata.pos)),Color3.fromRGB(255,0,0))
			blockdata.s = {bl.Size.X,bl.Size.Y,bl.Size.Z}
		else
			--createpartpos(CFrame.new(table.unpack(blockdata.pos)),Color3.fromRGB(0,255,0))
		end
--[[
		if bl.Material == Enum.Material. then
			blockdata.mat = ""
		end
]]
		blockdata.m = materials[bl.Material]
		blockdata.o = bl.Material.Name
		-- no toxify because we cant tell the difference between neon and toxify :(
		blockdata.sp = {}
		for i,v in pairs(bl:GetChildren()) do
			if v.Name == "Spray" then
				table.insert(blockdata.sp,{v.Face.Name,v.Image.Image,string.gsub(v.Label.Text,'"','\"')}) -- No work! :(
			end
		end
	end
	return blockdata
end
lib.makebutton("Save Build",bsaltab,function()
	local builddata = {}
	for i,v in pairs(workspace.Bricks[localplr.Name]:GetChildren()) do
		if v:IsA("BasePart") then
			table.insert(builddata,saveblock(v))
		end
	end
	local savebuildname2 = savebuildname
	if savebuildname == "Untitled" or table.find(getfn(),savebuildname) then
		if savebuildnames[savebuildname] == nil then
			savebuildnames[savebuildname] = 0
		end
		savebuildnames[savebuildname] = savebuildnames[savebuildname] + 1
		local savebuildamt = savebuildnames[savebuildname]
		savebuildname2 = savebuildname..tostring(savebuildamt)
	end
	writefile("TheChosenOneBuilds/"..savebuildname2..".json",http:JSONEncode(builddata))
	updatedropdown()
end)
lib.makebutton("Save Server Builds",bsaltab,function()
	local builddata = {}
	for i,v in pairs(workspace.Bricks:GetDescendants()) do
		if v:IsA("BasePart") then
			table.insert(builddata,saveblock(v))
		end
	end
	local savebuildname2 = savebuildname
	if savebuildname == "Untitled" or table.find(getfn(),savebuildname) ~= nil then
		if savebuildnames[savebuildname] == nil then
			savebuildnames[savebuildname] = 0
		end
		savebuildnames[savebuildname] = savebuildnames[savebuildname] + 1
		local savebuildamt = savebuildnames[savebuildname]
		savebuildname2 = savebuildname..tostring(savebuildamt)
	end
	writefile("TheChosenOneBuilds/"..savebuildname2..".json",http:JSONEncode(builddata))
	updatedropdown()
end)
local plrbuild = nil
local plrbuilds = {ServerBuilds = workspace.Bricks}
local plrnames = {"ServerBuilds"}
local hpb = true
local buildhighlight = Instance.new("Highlight")
buildhighlight.Parent = game.CoreGui
buildhighlight.FillColor = Color3.fromRGB(0,255,0)
buildhighlight.FillTransparency = .9
plrdropdown = lib.makedropdown("Select Player Builds",bsaltab,{},function(sel)
	plrbuild = plrbuilds[sel]
	buildhighlight.Adornee = plrbuild
end)
function upddd()
	table.sort(plrnames,function(a,b)
		return a:lower() < b:lower()
	end)
	lib.updatedropdown(plrdropdown,plrnames)
end
function dobricks(f,nud)
	plrbuilds[f.Name] = f
	if f:FindFirstChild("Brick") then
		table.insert(plrnames,f.Name)
	end
	table.insert(conn,f.ChildAdded:Connect(function(b)
		if not table.find(plrnames,f.Name) then
			table.insert(plrnames,f.Name)
			upddd()
		end
	end))
	table.insert(conn,f.ChildRemoved:Connect(function(b)
		if #f:GetChildren() <= 0 and table.find(plrnames,f.Name) then
			table.remove(plrnames,table.find(plrnames,f.Name))
			upddd()
		end
	end))
	if nud == nil then
		upddd()
	end
end
for i,v in pairs(workspace.Bricks:GetChildren()) do
	if v:IsA("Model") then
		dobricks(v,true)
	end
end
upddd()
local onbrick = workspace.Bricks.ChildAdded:Connect(function(child)
	dobricks(child)
end)
lib.maketoggle("Highlight Player Build",bsaltab,function()
	hpb = bool
	if not hpb then
		buildhighlight.FillTransparency = 1
		buildhighlight.OutlineTransparency = 1
	elseif hpb then
		buildhighlight.FillTransparency = .9
		buildhighlight.OutlineTransparency = 0
	end
end,true)
lib.makebutton("Save Player Build",bsaltab,function()
	local builddata = {}
	for i,v in pairs(plrbuild:GetChildren()) do
		if v:IsA("BasePart") then
			table.insert(builddata,saveblock(v))
		end
	end
	local savebuildname2 = savebuildname
	if savebuildname == "Untitled" or table.find(getfn(),savebuildname) ~= nil then
		if savebuildnames[savebuildname] == nil then
			savebuildnames[savebuildname] = 0
		end
		savebuildnames[savebuildname] = savebuildnames[savebuildname] + 1
		local savebuildamt = savebuildnames[savebuildname]
		savebuildname2 = savebuildname..tostring(savebuildamt)
	end
	writefile("TheChosenOneBuilds/"..savebuildname2..".json",http:JSONEncode(builddata))
	updatedropdown()
end)

lib.makelabel("loading/deleting builds",bsaltab)
builddropdown = lib.makedropdown("Saved Builds",bsaltab,{},function(sel)
	selectedbuild = {sel,http:JSONDecode(readfile("TheChosenOneBuilds/"..sel..".json"))}
end)
local bindfunc = Instance.new("BindableFunction")
bindfunc.OnInvoke = function(prompt)
	if prompt == "Yes" and selectedbuild ~= nil then
		delfile("TheChosenOneBuilds/"..selectedbuild[1]..".json")
		selectedbuild = nil
		updatedropdown()
	end
end
lib.makebutton("Delete Save",bsaltab,function()
	starterui:SetCore("SendNotification",{Title="Delete Save?",Text="Are you sure you want to delete the save?",Duration=5,Callback=bindfunc,Button1="Yes",Button2="No"})
end)
function getbuild()
	if selectedbuild then
		return selectedbuild[2]
	end
	return nil
end
local offset = Vector3.new(0,0,0)
lib.makebutton("Load Save",bsaltab,function()
	if selectedbuild ~= nil then
		local build = getbuild()
		if build then
			if oldprt then
				oldprt:Destroy()
			end
			for i,v in pairs(selectedbuild[2]) do
				if stopped == true then
					break
				end
				local blocktype = nil
				local args = {}
				local posses = (v.p or v.pos)
				args[1] = CFrame.new(posses[1],posses[2],posses[3]).Position + offset
				args[2] = v.m or v.mat
				args[3] = Color3.fromRGB(table.unpack(v.c or v.color))
				if v.s or v.size then
					args[5] = Vector3.new(table.unpack(v.s or v.size))
				end
				createpartrepl(args[1],args[5],args[3],swappedmaterials[v.m or v.mat])
				args[7] = v.o or v.origmat
				args[8] = v.sp or v.sprayed
				args[9] = v.a or v.anchored
				args[10] = v.cc or v.collide
				buildblock(args[1],args[2],args[3],nil,args[5],nil,args[7],args[8],args[9],args[10])
			end
			stopped = false
		end
	end
end)
function optimizebuilds()
	if selectedbuild ~= nil then
		local build = getbuild()
		if build then
			for i,v in pairs(selectedbuild[2]) do
				local p = CFrame.new(table.unpack(v.pos)).Position
				v.pos = nil
				v.p = {p.X,p.Y,p.Z}
				v.m = v.mat
				v.mat = nil
				v.s = v.size or nil
				v.size = nil
				v.c = v.color
				v.color = nil
				v.o = v.origmat
				v.origmat = nil
				v.sp = v.sprayed
				v.sprayed = nil
				v.a = v.anchored
				v.anchored = nil
				v.cc = v.collide
				v.collide = nil
			end
			writefile(selectedbuild[1],http:JSONEncode(selectedbuild[2]))
			updatedropdown()
		end
	end
end
lib.makelabel("extra settings/display build",bsaltab)
local offsetpart = Instance.new("Part")
offsetpart.Shape = Enum.PartType.Ball
offsetpart.Anchored = true
offsetpart.CanCollide = false
offsetpart.CastShadow = false
offsetpart.CanQuery = false
offsetpart.Color = Color3.new(0,1,0)
offsetpart.Transparency = 1
offsetpart.Size = Vector3.new(3,3,3)
offsetpart.CFrame = CFrame.new(0,0,0)
offsetpart.Parent = workspace
lib.makebutton("Offset Build",bsaltab,function()
	offset = round(workspace.Spawn.Position + game.Players.LocalPlayer.Character.HumanoidRootPart.Position)
	offsetpart.Position = offset
	offsetpart.Transparency = 0.5
end)
lib.makebutton("Reset Offset",bsaltab,function()
	offset = Vector3.new(0,0,0)
	offsetpart.Transparency = 1
end)
lib.makebutton("OPTIMIZE BUILD (if build is already optimized/saved after this update then it will error)",bsaltab,function()
	optimizebuilds()
end)
lib.makebutton("OPTIMIZE ALL BUILDS (RECOMMENDED)",bsaltab,function()
	local psb = selectedbuild
	for i,v in pairs(listfilesfixed("TheChosenOneBuilds/")) do
		local v2 = http:JSONDecode(readfile(v))
		selectedbuild = {v,v2}
		local s,e = pcall(optimizebuilds)
		if not s then print("Build Already Optimized! ("..v..") \n",e) end
	end
	selectedbuild = psb
end)
local prttable = nil
lib.makebutton("Display Whole Build (might lag, only you see)",bsaltab,function()
	if selectedbuild ~= nil then
		local build = getbuild()
		if build then
			if prttable then
				for i,v in pairs(prttable) do
					v:Destroy()
				end
			end
			local laggyparttable = {}
			for i,v in pairs(selectedbuild[2]) do
				local blocktype = nil
				local args = {}
				local posses = (v.pos or v.p)
				args[1] = CFrame.new(posses[1],posses[2],posses[3]).Position + offset
				args[2] = v.mat or v.m
				args[3] = Color3.fromRGB(table.unpack(v.color or v.c))
				if v.size or v.s then
					args[5] = Vector3.new(table.unpack(v.size or v.s))
				end
				local prt = createpartrepl(args[1],args[5],args[3],swappedmaterials[v.mat or v.m],0,v.anchored or v.a,v.collide or v.cc,v.sprayed or v.sp)
				table.insert(laggyparttable,prt)
			end
			prttable = laggyparttable
		end
	end
end)
lib.makebutton("Delete build display (might lag, only you see)",bsaltab,function()
	if prttable then
		for i,v in pairs(prttable) do
			v:Destroy()
		end
	end
end)
lib.makelabel("settings to make building faster",bsaltab)
lib.makelabel("The more brick history the more smooth the building will go, but if its too high it might lag",bsaltab)
lib.makelabel("Defaulted to 400",bsaltab)
lib.maketextbox("Brick History",bsaltab,function(txt)
	if tonumber(txt) then
		historymax = math.abs(tonumber(txt)) -- weirdoes setting it to negative numbers dont even think about it
		for i,v in pairs(cubehistory) do
			if i > historymax then
				cubehistory[i] = nil
			end
		end
	end
end)
lib.makelabel("if you have good wifi you should set the Wait before resizing lower",bsaltab)
lib.makelabel("defaulted to 0.4",bsaltab)
lib.makelabel("setting it too low may cause the script to not resize blocks properly",bsaltab)
local resizewaitlabel = nil
lib.maketextbox("Wait before resizing",bsaltab,function(txt)
	if tonumber(txt) then
		resizewait = tonumber(txt)
		lib.updatelabel("Resize Wait: "..tostring(resizewait),resizewaitlabel)
	end
end)
local lastwbs = resizewait
lib.maketoggle("Make wait before resizing based on ping",bsaltab,function(bool)
	wbs = bool
	if wbs then
		lastwbs = resizewait
	else
		resizewait = lastwbs
		lib.updatelabel("Resize Wait: "..tostring(resizewait),resizewaitlabel)
	end
end)
resizewaitlabel = lib.makelabel("Resize Wait: 0.4",bsaltab)
pinglabel = lib.makelabel("Ping: ???",bsaltab)
lib.makelabel("To make the auto resize wait work better turn on performance stats",bsaltab)
local ping = -100
coroutine.wrap(function()
	while ors do
		task.wait(1)
		if not wbs then continue end
		local newping = -199
		local s,e = pcall(function()
			for i,v in pairs(game:GetService("CoreGui").RobloxGui.PerformanceStats:GetChildren()) do
				if v:FindFirstChild("StatsMiniTextPanelClass") and v.StatsMiniTextPanelClass:FindFirstChild("TitleLabel") and v.StatsMiniTextPanelClass:FindFirstChild("ValueLabel") and v.StatsMiniTextPanelClass.TitleLabel.Text == "Ping" then
					newping = tonumber(string.sub(v.StatsMiniTextPanelClass.ValueLabel.Text,1,string.find(v.StatsMiniTextPanelClass.ValueLabel.Text," ms")-1))
				end
			end
		end)
		if not s then
			newping = localplr:GetNetworkPing()
		end
		if newping ~= ping then
			ping = newping
			historynum2 = historynum2 + 1
			if historynum2 > 5 then
				historynum2 = 1
			end
			local multi = 2.7
			if ping > 250 then
				multi = 2.5
			elseif ping > 500 then
				multi = 2.2
			end
			lib.updatelabel("Ping: "..tostring(ping),pinglabel)
			pinghistory[historynum2] = ping*multi -- added a little extra for fluctuations or whatever
			local allnums = 0
			for i,v in pairs(pinghistory) do
				allnums = allnums + v
			end
			resizewait = (allnums/#pinghistory)/1000
			lib.updatelabel("Resize Wait: "..tostring(resizewait),resizewaitlabel)
		end
	end
end)()
updatedropdown()
lib.makelabel("Pressing 'say' will not make you say to everyone, you say it privately",geartab)
lib.makelabel("Doing the say/copy will say/copy the gear id, not the gear name",geartab)
local currgears = {}
local chatgear = false
local gearcopybefore = "gear me "
lib.makebutton("Put gear id with 'gear me'",geartab,function()
	gearcopybefore = "gear me "
end)
lib.makebutton("Put gear id with 'gear all'",geartab,function()
	gearcopybefore = "gear all "
end)
lib.maketextbox("Put gear id with what you enter",geartab,function(txt)
	txt = string.gsub(txt,'"','\"')
	local len = string.len(txt)
	if len > 0 then
		if string.sub(txt,len,len) == " " then
			txt = string.sub(txt,1,len-1)
		end
		txt = txt.." "
	end
	gearcopybefore = txt
end)
local chat = nil
local s,e = pcall(function()
	chat = nil--require(game:GetService("Players").LocalPlayer:WaitForChild("PlayerScripts"):WaitForChild("ChatScript"):WaitForChild("ChatMain"))
end)
function say(text,channel)
	coroutine.wrap(function()
		--game:GetService("ReplicatedStorage"):WaitForChild("DefaultChatSystemChatEvents"):WaitForChild("SayMessageRequest"):FireServer(text,channel or "System")
		if not dumfix and channel and channel:lower() == "system" then
			if string.sub(text,1,1) ~= ";" then
				text = ";"..text
			end
			game:GetService("TextChatService").TextChannels.RBXSystem:SendAsync(text)
		else
			if string.sub(text,1,1) ~= ";" and dumfix then
				text = ";"..text
			end
			game:GetService("TextChatService").TextChannels.RBXGeneral:SendAsync(text)
		end
	end)()
end
local gsavenames = "tcogearsavenames.txt"
function savegears()
	local s,e = pcall(function()
		local tjson = game:GetService("HttpService"):JSONEncode(currgears)
		writefile(gsavenames,tjson)
	end)
end
function makegear(gearname,gearid,save,changename)
	deletegear(gearid)
	if changename == nil then
		changename = true
	end
	if changename then
	local foundcopy = false
	for i,v in pairs(currgears) do
		if v[3] == gearname then
			foundcopy = true
		end
	end
	if foundcopy then
		local n = 1
		local gearname2 = gearname
		repeat
			local foundcopy2 = false
			gearname2 = gearname.." "..tostring(n)
			for i,v in pairs(currgears) do
				if v[3] == gearname2 then
					foundcopy2 = true
				end
			end
			n = n + 1
			if not foundcopy2 then
				foundcopy = false
			end
			task.wait()
		until foundcopy == false
		gearname = gearname2
	end
	end
	local gbutton = lib.makebutton("Copy "..gearname,geartab,function()
		setclipboard(gearcopybefore..tostring(gearid))
	end)
	local gbutton2 = lib.makebutton("Say "..gearname,geartab,function()
		say(gearcopybefore..tostring(gearid),"system")
	end)
	if save then
		currgears[gearid] = {gbutton,gbutton2,gearname,gearid}
		savegears()
	end
end
function deletegear(gearid)
	if currgears[gearid] then
		local v = currgears[gearid]
		local s,e = pcall(function()
			v[1]:Destroy()
			v[2]:Destroy()
			currgears[gearid] = nil
			savegears()
		end)
	end
end
lib.makelabel("Preset Gears",geartab)
makegear("Pot Of Gold",24015579,false)
makegear("Merely's Web Slinger",169602010,false)
makegear("Dagger of Shattered Dimensions",71037101,false)
makegear("Portable Justice (Blacklisted)",82357101,false)
makegear("BB-8",1183007014,false)
makegear("BB-9E",1183007628,false)
makegear("Advanced Paint Bucket",18474459,false)
makegear("Rainbow Periastron",159229806,false)
makegear("Chartreuse Periastron",80661504,false)
makegear("Crimson Periastron",99119240,false)
makegear("Azure Periastron",69499437,false)
makegear("Noir Periastron",120307951,false)
makegear("Ivory Periastron",108158379,false)
makegear("Grimgold Periastron",73829193,false)
makegear("Amethyst Periastron",93136802,false)
makegear("Festive Periastron",139577901,false)
makegear("Joyful Periastron",233520257,false)
makegear("Fall Periastron",2544549379,false)
makegear("Fake Chartreuse Periastron",80597060,false)
makegear("Blizzard Wand",68354832,false)
makegear("Poseidon's Quake Trident",54130559,false)
makegear("Classic Bucket",25162389,false)
makegear("Vampire Vanquisher",94794847,false)
makegear("Exploding Heart",178076989,false)
makegear("Portable Beach (R6)",162857357,false)
makegear("Scroll of Sevenless",125013830,false)
makegear("Positronic Platform Producer",34898883,false)
makegear("Azure Dragon's Magic Slayer",268586231,false)
makegear("Azure Mines Pickaxe",583030187,false)
makegear("Body Swap Potion",78730532,false)
makegear("Crossbow of the Sea",236438668,false)
lib.makelabel("Custom Gears (creation)",geartab)
local gnamesel = "Untitled"
lib.maketextbox("Enter gear name",geartab,function(txt)
	txt = string.gsub(txt,'"','\"')
	gnamesel = txt
end)
local gidsel = "0"
lib.maketextbox("Enter gear id",geartab,function(txt)
	txt = string.gsub(txt,'"','\"')
	gidsel = txt
end)
lib.makebutton("Create Gear Buttons",geartab,function()
	if currgears[gidsel] then
		deletegear(gidsel)
	end
	makegear(gnamesel,gidsel,true)
end)
lib.maketextbox("Delete Gear Buttons (enter in id)",geartab,function(txt)
	deletegear(txt)
end)
lib.makelabel("Custom Gears",geartab)
local s,e = pcall(function()
	currgears = game:GetService("HttpService"):JSONDecode(readfile(gsavenames))
	if currgears == nil then
		currgears = {}
	end
	for i,v in pairs(currgears) do
		makegear(v[3],i,true,false)
	end
	savegears()
end)
local spamming = nil
lib.maketoggle("Spam Equipped Tools",tooltab,function(bool)
	if bool then
		spamming = true
	else
		spamming = nil
	end
end)
local dee = false
lib.maketoggle("Don't equip enlighten when dropping/equipping tools",tooltab,function(bool)
	dee = bool
end)
lib.makebutton("Equip All Tools",tooltab,function()
	for i,v in pairs(localplr.Backpack:GetChildren()) do
		if v:IsA("Tool") then
			if (dee and v.Name ~= "The Arkenstone") or not dee then
				v.Parent = localplr.Character
			end
		end
	end
end)
lib.makelabel("warning",tooltab)
lib.makebutton("Drop All Tools",tooltab,function()
	for i,v in pairs(localplr.Backpack:GetChildren()) do
		if v:IsA("Tool") then
			if (dee and v.Name ~= "The Arkenstone") or not dee then
				v.Parent = localplr.Character
			end
		end
	end
	task.wait()
	for i,v in pairs(localplr.Character:GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = workspace
		end
	end
end)
lib.makelabel("warning",tooltab)
local dee2 = true
lib.maketoggle("Don't equip enlighten when dropping tools (For auto drop)",tooltab,function(bool)
	dee2 = bool
end,true)
local pickuptools = true
local autodroptools = true
local currhum = nil
function dc(c)
	local f = c.ChildAdded:Connect(function(child)
		if child:IsA("Humanoid") then
			currhum = child
		end
	end)
	if c:FindFirstChild("Humanoid") then
		currhum = c.Humanoid
	end
	coroutine.wrap(function()
		repeat task.wait(10) until c == nil or c.Parent == nil
		f:Disconnect()
	end)()
end
if localplr.Character then
	dc(localplr.Character)
end
local onchradded = localplr.CharacterAdded:Connect(function(c)
	dc(c)
end)
local ot = false
local autoperm = false
local alwaysreset = false
local alwaysresetall = false
coroutine.wrap(function()
	repeat
		task.wait(.1)
		if currhum ~= nil and currhum.Parent ~= nil then
			if pickuptools and currhum.Health > 0 then
				for i,v in pairs(workspace:GetChildren()) do
					if v:IsA("Tool") and v:FindFirstChild("Handle") then
						currhum:EquipTool(v)
						if v.Name == "The Arkenstone" and autoperm then
							task.wait(.1)
						end
					end
				end
			end
			if autodroptools and currhum.Health <= 0 then
				for i,v in pairs(localplr.Backpack:GetChildren()) do
					if ((dee2 and v.Name ~= "The Arkenstone") or not dee2) then
						v.Parent = localplr.Character
					end
				end
				for i,v in pairs(localplr.Character:GetChildren()) do
					if v:IsA("Tool") and ((dee2 and v.Name ~= "The Arkenstone") or not dee2) then
						v.Parent = workspace
					end
				end
			end
		end
	until not on
end)()
lib.maketoggle("Auto Pickup Dropped Tools",tooltab,function(bool)
	pickuptools = bool
end,true)
lib.maketoggle("Auto Drop Tools On Death",tooltab,function(bool)
	autodroptools = bool
end,true)
local commands = {}
local heldtools = {}
local onrender = game:GetService("RunService").Heartbeat:Connect(function()
	if spamming and on then
		for i,v in pairs(localplr.Character:GetChildren()) do
			if v:IsA("Tool") then
				v:Activate()
			end
		end
	end
	if localplr.Character then
		for i,v in pairs(localplr.Character:GetChildren()) do
			if v:IsA("Tool") then
				if not heldtools[v.Name] then
					heldtools[v.Name] = 3
				end
				heldtools[v.Name] = heldtools[v.Name]-1
			end
		end
	end
	for i,v in pairs(heldtools) do
		if not localplr.Character or not localplr.Character:FindFirstChild(i) then
			heldtools[i] = nil
		end
	end
	local attemptreset = false
	if autoperm and localplr.Character and localplr.Character:FindFirstChild("The Arkenstone") then
		attemptreset = true
		if heldtools["The Arkenstone"] > 0 then
			say("reset me","system")
		end
	elseif autoperm and localplr.Backpack:FindFirstChild("The Arkenstone") and localplr:GetAttribute("Arken") ~= true and localplr.Character then
		localplr.Backpack["The Arkenstone"].Parent = localplr.Character
		attemptreset = true
		if heldtools["The Arkenstone"] > 0 then
			say("reset me","system")
		end
	end
	if alwaysreset then
		attemptreset = true
	   	say("reset me","system")
	end
	if alwaysresetall then
		say("reset all","system")
	end
	if not attemptreset then
		for i,v in pairs(commands) do
			if v == true then
				say(i,"system")
			end
		end
	end
	if novel == true and localplr.Character and localplr.Character:FindFirstChild("HumanoidRootPart") then
		localplr.Character.HumanoidRootPart.Velocity = Vector3.new(0,0,0)
	end
end)
lib.maketoggle("Auto Permanent Enlighten (PATCHED)",scripttab,function(bool)
	autoperm = bool
end)
lib.maketoggle("Spam reset",scripttab,function(bool)
	alwaysreset = bool
end)
lib.maketoggle("Spam reset all",scripttab,function(bool)
	alwaysresetall = bool
end)
lib.makelabel("Since the chosen one updated to the new roblox chat, the no chat logger no longer works, use the 'clear chat logs' thing.",scripttab)
function clearclogs(amt)
	for i=1,amt do
		coroutine.wrap(function()
			say(";","system")
		end)()
	end
end
lib.makelabel("The clear chat of logs makes it so that if someone reports you, roblox will look into your first 10-15 chats (which will be cleared) and u wont get banned",scripttab)
lib.makelabel("(however, you have to manually clear it and you cant chat for a few seconds)",scripttab)
lib.makelabel("clear chat log by vxsty",scripttab)
lib.makebutton("Clear chat of logs (10)",scripttab,function()
	clearclogs(10)
end)
lib.makebutton("Clear chat of logs (20)",scripttab,function()
	clearclogs(20)
end)
local ccol = false
lib.maketoggle("Always clear chat of logs (RECOMMENDED, COMMANDS WONT WORK WHEN ENABLED)",scripttab,function(bool)
	ccol = bool
	while ccol do
		task.wait()
		clearclogs(5)
	end
end)
local threeemdash = "\u{2E3B}"
lib.maketextbox("Say Long Message (broken D:)",scripttab,function(input)
	if input == "" or input == nil then
		input = "200"
	end
	input = tonumber(input)
	say(string.rep(threeemdash,input),"All")
end)
lib.makelabel("warning",scripttab)
lib.makebutton("Execute Fling All Script",scripttab,function()
	if loadfile ~= nil and writefile ~= nil and readfile ~= nil then
		local cache = nil
		local success,err = pcall(function()
			cache = readfile("CachedFlingAll.txt")
		end)
		if not cache then
			cache = game:HttpGet("https://rawscripts.net/raw/Universal-Script-FLING-ALL-SCRIPT-17590")
			writefile("CachedFlingAll.txt",cache)
		end
		loadstring(cache)()
	else
		loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-FLING-ALL-SCRIPT-17590"))()
	end
end)
lib.makelabel("warning",scripttab)
lib.makebutton("Join VC Server",scripttab,function()
	game:GetService("TeleportService"):Teleport(12943247001,localplr)
end)
lib.makelabel("warning",scripttab)
local dbut = nil
dbut = lib.makebutton("Execute Zte Hub (HAS SILENT COMMAND LOGGER!)",scripttab,function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/khanh-lol/Ztehub/refs/heads/main/zte"))() 
	dbut:Destroy()
end)
local savefile = "tcospamcommandssave.txt"
local spamtxtssave = {}
local spamtxtinstance = {}
local spamnum = 0
local truncatetxt = true
local spamcmd = true
function addcmd(txt,save,index,start)
	local spamtxt = false
	if not index then
		if #spamtxtssave > 0 then
			for i,v in pairs(spamtxtssave) do
				if spamtxtssave[i+1] == nil then
					index = i+1
					break
				end
			end
		else
			index = 1
		end
	end
	spamnum = index
	local num = spamnum
	if save then
		spamtxtssave[spamnum] = txt
		--spamtxtssave["max"] = spamnum
	end
	local previewcmd = string.split(txt," ")[1]
	if not truncatetxt then
		previewcmd = txt
	end
	local tog = nil
	if spamcmd then
		commands[txt] = start or false
		tog = lib.maketoggle("Spam Command/Text ("..previewcmd.." "..tostring(num)..")",commandtab,function(bool)
			commands[txt] = bool
		end,start or nil)
	else
		commands[txt] = false
		tog = lib.makebutton("Say Command/Text ("..previewcmd.." "..tostring(num)..")",commandtab,function()
			if not attemptreset then
				say(txt,"system")
			end
		end)
	end
	spamtxtinstance[spamnum] = {tog,txt}
	if save then
		writefile(savefile,http:JSONEncode(spamtxtssave))
	end
	for i,v in pairs(spamtxtinstance) do
		v[1].LayoutOrder = i
	end
end
lib.maketoggle("Truncate/Shorten Text",commandtab,function(bool)
	truncatetxt = bool
	for i,v in pairs(spamtxtinstance) do
		v[1]:Destroy()
		--spamtxtinstance[i] = nil
	end
	for i,v in pairs(spamtxtssave) do
		i = tonumber(i)
		addcmd(v,false,i,commands[v])
	end
end,true)
lib.maketoggle("Spam Commands",commandtab,function(bool)
	spamcmd = bool
	for i,v in pairs(spamtxtinstance) do
		v[1]:Destroy()
		--spamtxtinstance[i] = nil
	end
	for i,v in pairs(spamtxtssave) do
		i = tonumber(i)
		addcmd(v,false,i,commands[v])
	end
end,true)
lib.maketextbox("Enter Command",commandtab,function(txt)
	txt = string.gsub(txt,'"','\"')
	addcmd(txt,true)
end)
lib.maketextbox("Remove Command (put exact command)",commandtab,function(txt)
	for i,v in pairs(spamtxtssave) do
		if v == txt then
			spamtxtssave[i] = nil
		end
	end
	commands[txt] = false
	for i,v in pairs(spamtxtinstance) do
		if v[2] == txt then
			v[1]:Destroy()
		end
	end
	writefile(savefile,http:JSONEncode(spamtxtssave))
end)
local bindfunc = Instance.new("BindableFunction")
bindfunc.OnInvoke = function(prompt)
	if prompt == "Yes" then
		for i,v in pairs(spamtxtinstance) do
			v[1]:Destroy()
			spamtxtinstance[i] = nil
		end
		commands = {}
		spamtxtssave = {}
		writefile(savefile,http:JSONEncode(spamtxtssave))
	end
end
lib.makebutton("Reset All Commands",commandtab,function()
	starterui:SetCore("SendNotification",{Title="Delete Commands?",Text="Are you sure you want to reset the commands?",Duration=5,Callback=bindfunc,Button1="Yes",Button2="No"})
end)
lib.makelabel("",commandtab)
local s,e = pcall(function()
	local save = readfile(savefile)
	if save then
		spamtxtssave = http:JSONDecode(save) or {}
		for i,v in pairs(spamtxtssave) do
			i = tonumber(i)
			addcmd(v,false,i)
			--elseif i == "max" then
				--spamnum = v
		end
	end
end)

local spychat = true
lib.maketoggle("SPY CHAT",modtab,function(bool)
	spychat = bool
end,true)
local namecolors = {
	peasant={150,103,102},
	arken={4,175,236},
	admin={245,205,48},
	hidden={255,0,0},
	iqgenius={255,179,179},
	iqdumb={200,0,0}
}
if isog then
	namecolors.peasant = {128,128,128}
end
local namecolorshex = {}
for i,v in pairs(namecolors) do
	namecolorshex[i] = "#"..Color3.fromRGB(table.unpack(v)):ToHex()
end
local joincmds = {
	joinxl="JoinXL",
	joinvc="JoinVC",
	joinog="JoinOG"
}
function oimremake(mdata)
	local plr = mdata.TextSource and mdata.TextSource.UserId and game.Players:GetPlayerByUserId(mdata.TextSource.UserId)
	if not plr then
		return
	end
	local cn = ""
	local hidden = false
	if plr.Neutral == true then
		if plr:GetAttribute("Arken") == true then
			cn = "arken"
		else
			cn = "peasant"
		end
	else
		cn = "admin"
	end
	local muted = plr:HasTag("Muted")
	if muted then
		cn = "hidden"
		if (not on or not spychat) then
			mdata.Text = ""
		end
	end
	local cmd = string.sub(mdata.Text,1,string.find(mdata.Text," ") or nil)
	if string.sub(mdata.Text,1,1) == ";" then
		cmd = string.sub(mdata.Text,2,string.find(mdata.Text," ") or nil)
		if on and spychat then
			cn = "hidden"
			hidden = true
		else
			mdata.Text = ""
		end
		--mdata.Text = string.sub(mdata.Text,2)
	end
	if plr == game.Players.LocalPlayer and joincmds[cmd:lower()] then
		for i,v in pairs(joincmds) do
			if localplr.PlayerGui:FindFirstChild(v) then
				localplr.PlayerGui[v].Enabled = i == cmd:lower()
			end
		end
	end
	local iq = nil
	if on and spychat and plr:GetAttribute("IQ") then
		if plr:GetAttribute("IQ") >= 200 then
			iq = "genius \u{1F9E0}"
			cn = "iqgenius"
		elseif plr:GetAttribute("IQ") <= 50 then
			iq = "dumb \u{1F92A}"
			cn = "iqdumb"
		end
	end
	if isog then
		mdata.PrefixText = "<font color=\""..namecolorshex[cn].."\"><b><font color='rgb("..tostring(namecolors[cn][1])..","..tostring(namecolors[cn][2])..","..tostring(namecolors[cn][3])..")'>["..plr.DisplayName..((hidden and " (HIDDEN CHAT)") or "")..((iq and (" ("..iq..")")) or "")..((muted and (" (MUTED)")) or "").."]: </font></b></font>"
	else
		mdata.PrefixText = "<font color=\""..namecolorshex[cn].."\"><i><font color='rgb("..tostring(namecolors[cn][1])..","..tostring(namecolors[cn][2])..","..tostring(namecolors[cn][3])..")'>("..plr.DisplayName..((hidden and " (HIDDEN CHAT)") or "")..((iq and (" ("..iq..")")) or "")..((muted and (" (MUTED)")) or "")..") </font></i></font>"
	end
end
game.TextChatService.OnIncomingMessage = oimremake

local blocktxt = lib.makelabel("No Block Selected",modtab)
lib.maketoggle("Outline Selected Block",modtab,function(bool)
	osb = bool
	if osb then
		sbox.LineThickness = 0.05
	else
		sbox.LineThickness = -1
	end
end)
lib.makelabel("",modtab)
local bboxtxt = lib.makelabel("No Boombox Selected",modtab)
local bbid = ""
lib.makebutton("Copy Boombox Sound ID",modtab,function()
	setclipboard(bbid)
end)
local osbb = false
lib.maketoggle("Outline Selected Boombox",modtab,function(bool)
	osbb = bool
	if osbb then
		bbsbox.LineThickness = 0.1
	else
		bbsbox.LineThickness = -1
	end
end)
local boomboxnames = {}
boomboxnames["SuperFlyGoldBoombox"] = true
boomboxnames["BoomboxGearThree"] = true
boomboxnames["DualGoldenSuperFlyBoombox"] = true
boomboxnames["DubstepBoombox"] = true
boomboxnames["BeatUpBoombox"] = true
inputbegan = game:GetService("UserInputService").InputBegan:Connect(function(input)
	if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) then
		local mousepart = mouse.Target
		if mousepart then
			if mousepart:IsDescendantOf(workspace.Bricks) then
				local plr = game.Players:FindFirstChild(mousepart.Parent.Name)
				local plrtxt = ""
				if plr then
					if plr.DisplayName == plr.Name then
						plrtxt = plr.Name
					else
						plrtxt = plr.DisplayName.."/"..plr.Name
					end
				else
					plrtxt = mousepart.Parent.Name.." (NOT INGAME)"
				end
				if mousepart.Parent.Parent == workspace then
					plrtxt = "Server Build (Not from anyone)"
				end
				lib.updatelabel("Block is from: "..plrtxt,blocktxt)
				if oss then
					lib.updatelabel("Block is from: "..plrtxt,blocktxt2)
					ssbox.Adornee = mousepart
					ssbox.Face = side
					sblock = mousepart
				end
				if ss then
					local ctm = nil
					for i,v in pairs(normalids) do
						local pos = mousepart.Position + (v[1]*mousepart.Size[v[2]]/2)
						if ctm == nil then
							ctm = {i,(mouse.Hit.Position - pos).Magnitude}
						elseif (mouse.Hit.Position - pos).Magnitude < ctm[2] then
							ctm = {i,(mouse.Hit.Position - pos).Magnitude}
						end
					end
					side = ctm[1]
					ssbox.Face = side
				end
			else
				lib.updatelabel("No Block Selected",blocktxt)
				sbox.Adornee = nil
			end
			if boomboxnames[mousepart.Parent.Name] == true then
				local sound = mousepart.Parent:FindFirstChild("Sound",true)
				if sound.SoundId == nil or sound.SoundId == "" then
					lib.updatelabel("No sound is playing on the boombox!",bboxtxt)
					bbid = ""
				else
					bbid = string.sub(sound.SoundId,string.find(sound.SoundId,"id=")+3)
					lib.updatelabel("Boombox ID: "..bbid,bboxtxt)
				end
				bbsbox.Adornee = mousepart.Parent.Handle
			else
				lib.updatelabel("No Boombox Selected",bboxtxt)
				bbsbox.Adornee = nil
			end
		else
			lib.updatelabel("No Block Selected",blocktxt)
			sbox.Adornee = nil
			lib.updatelabel("No Boombox Selected",bboxtxt)
			bbsbox.Adornee = nil
		end
	end
end)

local groups = {}
groups[5345749] = {"Chosen One Enthusiasts Club",Color3.fromRGB(0,255,0)}
groups[35956339] = {"Clementiuilo",Color3.fromRGB(108,77,59)}
groups[33203248] = {"Roblox's Rejects",Color3.fromRGB(177,125,82)}
groups[35155850] = {"Unchainable Mercy",Color3.fromRGB(108,77,59)}
groups[35985581] = {"Genesis",Color3.fromRGB(82,138,174)}
groups[33258647] = {"Union of Mirrland Communist States",Color3.fromRGB(120,0,0)}
groups[34915496] = {"dauens silly",{0,120,0}}
groups[34348476] = {"Frigid's silly fan club",Color3.fromRGB(0,0,200)}
groups[34838919] = {"Cult Of Combat",Color3.fromRGB(255,0,0)}
groups[34838919] = {"The Eternal Flame of TCO",Color3.fromRGB(255,255,0)}
groups[35986983] = {"Realm ???",Color3.fromRGB(42,73,199)}
local dheads = {}
function plradded(plr)
	local owner = scrowners[plr.UserId]
	local nahhh = plr.Name == "Visible_Threat"
	local beggar = plr.Name == "Skibisaacjacob" or plr.Name == "spiralrblxofficial"
	local group = false
	for i,v in pairs(groups) do
		if plr:IsInGroup(i) then
			local nv = v
			table.insert(v,i)
			group = nv
		end
	end
	if owner or group or nahhh or beggar then
		function onchar(c)
			coroutine.wrap(function()
				c:WaitForChild("Head",math.huge)
				local bbgui = Instance.new("BillboardGui")
				dheads[c.Head] = bbgui
				bbgui.Size = UDim2.new(10,0,1.5,0)
				bbgui.StudsOffset = Vector3.new(0,3.5,0)
				bbgui.Parent = c.Head
				local txt = Instance.new("TextLabel")
				txt.TextScaled = true
				txt.BackgroundTransparency = 1
				txt.Size = UDim2.new(1,0,1,0)
				txt.Position = UDim2.new(0,0,-0.5,0)
				txt.TextStrokeTransparency = 0
				local infotxt = Instance.new("TextLabel")
				infotxt.TextScaled = true
				infotxt.BackgroundTransparency = 1
				infotxt.Size = UDim2.new(1,0,0.5,0)
				infotxt.Position = UDim2.new(0,0,0.5,0)
				infotxt.TextStrokeTransparency = 0
				if owner then
					txt.Text = "Script Owner (Extra Stuff)"
					infotxt.Text = "Don't ask me for the 'tag' script, you only see this when you execute the script."
					txt.TextColor3 = Color3.fromRGB(200,90,0)
				elseif beggar then
					txt.Text = "Beggar"
					infotxt.Text = "laugh at this person please"
					txt.TextColor3 = Color3.fromRGB(0,100,0)
				elseif nahhh then
					txt.Text = "I'm Not Tuff"
					infotxt.Text = "stop using my script, you are not tuff!"
					txt.TextColor3 = Color3.fromRGB(255,0,0)
				elseif group then
					txt.Text = group[1]
					txt.TextColor3 = group[2]
					infotxt.Text = plr:GetRoleInGroup(group[3])
				end
				txt.Parent = bbgui
				infotxt.TextColor3 = txt.TextColor3
				infotxt.Parent = bbgui
			end)()
		end
		if plr.Character then
			onchar(plr.Character)
		end
		table.insert(conn,plr.CharacterAdded:Connect(onchar))
	end
end
for i,v in pairs(game.Players:GetPlayers()) do
	plradded(v)
end
local onplr = game.Players.PlayerAdded:Connect(plradded)
lib.ondestroyedfunc = function()
	on = false
	ot = false
	ccol = false
	stopped = true
	skipblock = true
	autoperm = false
	alwaysreset = false
	alwaysresetall = false
	built = true
	spychat = false
	cubechild:Disconnect()
	onrender:Disconnect()
	inputbegan:Disconnect()
	highlight:Destroy()
	onplr:Disconnect()
	daura = false
	dauras = false
	ors = false
	daurapart:Destroy()
	for i,v in pairs(commands) do
		v = false
	end
	pickuptools = false
	autodroptools = false
	onchradded:Disconnect()
	dee2 = false
	dee = false
	spmbl = false
	spmsi = false
	if prttable then
		for i,v in pairs(prttable) do
			v:Destroy()
		end
	end
	--writefile(savefile,http:JSONEncode(spamtxtssave))
	wbs = false
	if oldprt then
		oldprt:Destroy()
	end
	sbox.Adornee = nil
	sbox:Destroy()
	bbsbox.Adornee = nil
	bbsbox:Destroy()
	for i,v in pairs(conn) do
		v:Disconnect()
	end
	for i,v in pairs(dheads) do
		if v then
			v:Destroy()
		end
	end
	ssbox.Adornee = nil
	ssbox:Destroy()
	spmsb = false
	ss = false
	tp = false
	onbrick:Disconnect()
	buildhighlight:Destroy()
	offsetpart:Destroy()
end
end)
if not success then print(err) end
