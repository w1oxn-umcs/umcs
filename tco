local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
	Name = "Union of Mirrland Communist States",
	Icon = 0,
	LoadingTitle = "MirrlandBot Script",
	LoadingSubtitle = "by Alexei Petrov",
	ShowText = "Rayfield",
	Theme = "Default",

	ToggleUIKeybind = "K",

	DisableRayfieldPrompts = false,
	DisableBuildWarnings = false,

	ConfigurationSaving = {
		Enabled = true,
		FolderName = nil,
		FileName = "Big Hub"
	},

	Discord = {
		Enabled = false,
		Invite = "noinvitelink",
		RememberJoins = true
	},

	KeySystem = false,
	KeySettings = {
		Title = "Untitled",
		Subtitle = "Key System",
		Note = "No method of obtaining the key is provided",
		FileName = "Key",
		SaveKey = true,
		GrabKeyFromSite = false,
		Key = {"Hello"}
	}
})

local MainTab = Window:CreateTab("Main", 0)
local MainSection = MainTab:CreateSection("Main")

local Button = MainTab:CreateButton({
   Name = "The Chosen One Auto-Build",
   Callback = function()
		local success,err = pcall(function()
getgenv().deletewhendupefound = true
local localplr = game.Players.LocalPlayer
local mult = 4
local built = false
local colorbool = false
local stopped = false
local skipblock = false
local on = true
local conn = {}
local highlight = Instance.new("Highlight")
highlight.Parent = game.CoreGui
highlight.FillColor = Color3.fromRGB(255,255,255)
highlight.FillTransparency = .9
local mouse = localplr:GetMouse()
local sbox = Instance.new("SelectionBox")
sbox.Color3 = Color3.fromRGB(0,170,255)
sbox.LineThickness = -1
sbox.SurfaceColor3 = Color3.fromRGB(13,105,172)
sbox.SurfaceTransparency = 1
sbox.Transparency = 0
sbox.Parent = game.CoreGui
local bbsbox = Instance.new("SelectionBox")
bbsbox.Color3 = Color3.fromRGB(0,170,255)
bbsbox.LineThickness = -1
bbsbox.SurfaceColor3 = Color3.fromRGB(13,105,172)
bbsbox.SurfaceTransparency = 1
bbsbox.Transparency = 0
bbsbox.Parent = game.CoreGui
local uis = game:GetService("UserInputService")
local localplr = game.Players.LocalPlayer
local mouse = localplr:GetMouse()
local dragging = {}
function dragtopos(fpos,spos,pos,frame,bounds,ar)
    local finalpos = UDim2.new(
        frame.Position.X.Scale,
        spos.X.Offset-(fpos.X.Offset-pos.X),
        frame.Position.Y.Scale,
        spos.Y.Offset-(fpos.Y.Offset-pos.Y)
    )
    if bounds ~= nil then
        local UI = Instance.new("ScreenGui")
        UI.ScreenInsets = Enum.ScreenInsets.None 
        UI.Parent = game.CoreGui
        local screensize = UI.AbsoluteSize
        UI.Enabled = true
        local replframe = frame:Clone()
        replframe.Parent = UI
        replframe.Position = finalpos
        local absp = replframe.AbsolutePosition
        local abss = replframe.AbsoluteSize
        --[[
        replframe.Position = UDim2.new(0,0,0,0)
        local abspl = replframe.AbsolutePosition.X-replframe.AbsoluteSize.X
        local abspt = replframe.AbsolutePosition.Y+replframe.AbsoluteSize.Y
        replframe.Position = UDim2.new(1,0,1,0)
        local abspr = replframe.AbsolutePosition.X
        local abspb = screensize.Y-replframe.AbsolutePosition.Y
        local left = absp.X-abss.X < abspl
        local right = absp.X+abss.X > abspr
        local bottom = absp.Y+abss.Y > abspb
        local top = absp.Y+abss.Y < abspt
        ]]
        finalpos = UDim2.new(
            finalpos.X.Scale,
            math.clamp(
                finalpos.X.Offset,
                -finalpos.X.Scale*screensize.X,
                -finalpos.X.Scale*screensize.X+(screensize.X-abss.X)
            ),
            finalpos.Y.Scale,
            math.clamp(
                finalpos.Y.Offset,
                -finalpos.Y.Scale*screensize.Y,
                (-finalpos.Y.Scale*screensize.Y)+(screensize.Y-abss.Y)
            )
        )
        --[[
        print(left,right,bottom,top)
        if left then
            finalpos = UDim2.new(
                finalpos.X.Scale,
                -finalpos.X.Scale*screensize.X,
                finalpos.Y.Scale,
                finalpos.Y.Offset
            )
        elseif right then
            finalpos = UDim2.new(
                finalpos.X.Scale,
                (-finalpos.X.Scale*screensize.X)+(screensize.X-abss.X),
                finalpos.Y.Scale,
                finalpos.Y.Offset
            )
        end 
        if top then
            finalpos = UDim2.new(
                finalpos.X.Scale,
                finalpos.X.Offset,
                finalpos.Y.Scale,
                -finalpos.Y.Scale*screensize.Y
            )
        elseif bottom then
            finalpos = UDim2.new(
                finalpos.X.Scale,
                finalpos.X.Offset,
                finalpos.Y.Scale,
                (-finalpos.Y.Scale*screensize.Y)+(screensize.Y-abss.Y)
            )
        end
        ]]
        UI:Destroy()
    end
    frame.Position = finalpos
end
local drag = function(frame,bounds,chf)
    local frames = {}
    if frame:IsA("ScreenGui") then
        for i,v in pairs(frame:GetChildren()) do
            if chf ~= nil and (v:IsA("Frame") or v:IsA("ScrollingFrame")) then
                table.insert(frames,v)
            elseif not chf then
                table.insert(frames,v)
            end
        end
    else
        table.insert(frames,frame)
    end
    for i,frame in pairs(frames) do
        frame.Active = true
        local w,h = frame.AbsoluteSize.X,frame.AbsoluteSize.Y
        local ar = w/h
        frame.InputBegan:Connect(function(input)
            if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) and not dragging[input] then
                dragging[input] = frame
                local firstpos = UDim2.new(0,mouse.X,0,mouse.Y)
                local startpos = frame.Position
                local move1 = uis.TouchMoved:Connect(function(input2)
                    if input == input2 then
                        dragtopos(firstpos,startpos,input2.Position,frame,bounds or nil,ar)
                    end
                end)
                local move2 = uis.InputChanged:Connect(function(input2)
                    if input2.UserInputType == Enum.UserInputType.MouseMovement then
                        dragtopos(firstpos,startpos,input2.Position,frame,bounds or nil,ar)
                    end
                end)
                repeat task.wait() until dragging[input] == nil
                move1:Disconnect()
                move2:Disconnect()
            end
        end)
        uis.InputEnded:Connect(function(input)
            dragging[input] = nil
        end)
        uis.InputBegan:Connect(function(input)
            dragging[input] = true
        end)
    end
end
return drag
if not getgenv().bgcolor then
	getgenv().bgcolor = Color3.fromRGB(60,60,60)
end
if not getgenv().areyoumentaluis then
    getgenv().areyoumentaluis = {}
end
if not getgenv().deletewhendupefound then
	getgenv().deletewhendupefound = false
end
local lib = {}
lib.bgcolor = bgcolor
local connectfuncs = {}
local dropdownstuff = {}
local tabnum = 0
local amtsize = 100000
local amtsize2 = amtsize*10
local localplr = game.Players.LocalPlayer
local titletext = ""
function lib.makelib(titletext2)
    titletext = titletext2 or "Untitled"
    if deletewhendupefound == true and getgenv().areyoumentaluis[titletext] then
        getgenv().areyoumentaluis[titletext]:Destroy()
    end
    getgenv().areyoumentaluis[titletext] = Instance.new'ScreenGui'
    local mainframe = Instance.new'Frame'
    getgenv().areyoumentaluis[titletext].Parent = game.CoreGui
    mainframe.Parent = getgenv().areyoumentaluis[titletext]
    mainframe.Size = UDim2.new(.3,0,.375,0)
    mainframe.Position = UDim2.new(.35,0,.5-(.375/2))
    drag(mainframe)
    mainframe.BorderColor3 = Color3.fromRGB(255,255,255)
    mainframe.BackgroundColor3 = bgcolor
	local uiconstraint = Instance.new("UIAspectRatioConstraint")
	uiconstraint.Parent = mainframe
	uiconstraint.AspectRatio = 2
    local exitbutton = Instance.new'TextButton'
    exitbutton.Parent = mainframe
    exitbutton.Size = UDim2.new(.15,0,.2,0)
    exitbutton.Position = UDim2.new(.88,0,-.02,0)
    exitbutton.BackgroundTransparency = 1
    exitbutton.TextScaled = true
    exitbutton.Text = "X"
    exitbutton.TextColor3 = Color3.fromRGB(255,0,0)
    exitbutton.TextStrokeTransparency = 0
    exitbutton.ZIndex = 5
    local title = Instance.new'TextLabel'
    title.Parent = mainframe
    title.Size = UDim2.new(.910,0,.14,0)
    title.BorderColor3 = Color3.fromRGB(255,255,255)
    title.BackgroundColor3 = bgcolor
    title.TextScaled = true
    title.Text = titletext
    title.TextColor3 = Color3.fromRGB(255,255,255)
    title.TextStrokeTransparency = 0    
    table.insert(connectfuncs,exitbutton.MouseButton1Click:Connect(function()
		local bindfunc = Instance.new("BindableFunction")
		function bindfunc.OnInvoke(bpress)
			if bpress == "Yes" then
				mainframe.Parent:Destroy()
			end
		end
		game:GetService("StarterGui"):SetCore("SendNotification",{Title="Notification",Text="Close out of the script?",Callback=bindfunc,Button1="Yes",Button2="No"})
    end))
    table.insert(connectfuncs,getgenv().areyoumentaluis[titletext].Destroying:Connect(function()
        for i,v in pairs(connectfuncs) do
            v:Disconnect()
        end
		if lib.ondestroyedfunc then
			lib.ondestroyedfunc()
		end
    end))
    return getgenv().areyoumentaluis[titletext],mainframe
end
function lib.maketab(name)
    tabnum += 1
    local tabbutton = Instance.new'TextButton'
    tabbutton.Size = UDim2.new(.25,0,.15,0)
    tabbutton.ZIndex = -tabnum
    tabbutton.Parent = getgenv().areyoumentaluis[titletext].Frame
    tabbutton.BackgroundColor3 = bgcolor
    tabbutton.TextColor3 = Color3.fromRGB(255,255,255)
    tabbutton.TextScaled = true
    tabbutton.Text = name
    tabbutton.BorderColor3 = Color3.fromRGB(255,255,255)
    local tabframe = Instance.new'ScrollingFrame'
    tabframe.Parent = getgenv().areyoumentaluis[titletext].Frame
    tabframe.Size = UDim2.new(1,0,.820,0)
    tabframe.Position = UDim2.new(0,0,.160,0)
    tabframe.BackgroundColor3 = bgcolor
    tabframe.BorderColor3 = Color3.fromRGB(255,255,255)
    tabframe.Visible = false
	tabframe.CanvasSize = UDim2.new(0,0,amtsize,0)
    local sort = Instance.new'UIListLayout'
    sort.Parent = tabframe
    sort.SortOrder = "LayoutOrder"
    local ypos = -(((math.floor(tabnum/4.001))/8)*1.1+.15)
    if tabnum%4 == 1 then
        tabbutton.Position = UDim2.new(0,0,ypos)
    elseif tabnum%4 == 2 then
        tabbutton.Position = UDim2.new(.25,0,ypos)
    elseif tabnum%4 == 3 then
        tabbutton.Position = UDim2.new(.50,0,ypos)
    elseif tabnum%4 == 0 then
        tabbutton.Position = UDim2.new(.75,0,ypos)
    end
    local thistabnum = tabnum
    table.insert(connectfuncs,tabbutton.MouseEnter:Connect(function()
        tabbutton.Position = UDim2.new(tabbutton.Position.X.Scale,0,ypos)
        tabbutton.Size = UDim2.new(.25,0,.2,0)
        tabbutton.ZIndex = 20
    end))
    table.insert(connectfuncs,tabbutton.MouseLeave:Connect(function()
        tabbutton.Position = UDim2.new(tabbutton.Position.X.Scale,0,ypos)
        tabbutton.Size = UDim2.new(.25,0,.15,0)
        tabbutton.ZIndex = -thistabnum
    end))
    table.insert(connectfuncs,tabbutton.MouseButton1Click:Connect(function()
        for i,v in pairs(tabbutton.Parent:GetChildren()) do
            if v:IsA("ScrollingFrame") then
                v.Visible = false
            end
        end
        tabframe.Visible = true
    end))
    return tabframe
end
function lib.makelabel(name,tab)
    local label = Instance.new'TextLabel'
    label.Parent = tab
    label.Size = UDim2.new(.95,0,2/amtsize2,0)
    label.TextScaled = true
    label.TextColor3 = Color3.fromRGB(255,255,255)
    label.BackgroundColor3 = Color3.fromRGB(math.abs((bgcolor.R*255)-40),math.abs((bgcolor.G*255)-40),math.abs((bgcolor.B*255)-40))
    label.BorderColor3 = Color3.fromRGB(255,255,255)
    label.Text = name
    return label
end
function lib.makebutton(name,tab,func)
    local button = Instance.new'TextButton'
    button.Parent = tab
    button.Size = UDim2.new(.95,0,2/amtsize2,0)
    button.TextScaled = true
    button.TextColor3 = Color3.fromRGB(255,255,255)
    button.BackgroundColor3 = Color3.fromRGB(math.abs((bgcolor.R*255)-20),math.abs((bgcolor.G*255)-20),math.abs((bgcolor.B*255)-20))
    button.BorderColor3 = Color3.fromRGB(255,255,255)
    button.Text = name
    table.insert(connectfuncs,button.MouseButton1Click:Connect(func))
	return button
end
function lib.makeslider(name,tab,min,max,func)
    local sliderframe = Instance.new'Frame'
    sliderframe.Parent = tab
    sliderframe.Size = UDim2.new(.95,0,2/amtsize2,0)
    sliderframe.BackgroundColor3 = Color3.fromRGB(40,40,40)
    sliderframe.BorderColor3 = Color3.fromRGB(255,255,255)
    local nametext = Instance.new'TextLabel'
    nametext.Parent = sliderframe
    nametext.Size = UDim2.new(.4,0,1,0)
    nametext.TextScaled = true
    nametext.TextColor3 = Color3.fromRGB(255,255,255)
    nametext.BackgroundColor3 = Color3.fromRGB(20,20,20)
    nametext.BorderColor3 = Color3.fromRGB(255,255,255)
    nametext.Text = name
    local num = Instance.new'TextLabel'
    num.Parent = sliderframe
    num.Size = UDim2.new(.1,0,1,0)
    num.Position = UDim2.new(.4,0,0,0)
    num.TextScaled = true
    num.TextColor3 = Color3.fromRGB(255,255,255)
    num.BackgroundColor3 = Color3.fromRGB(20,20,20)
    num.BorderColor3 = Color3.fromRGB(255,255,255)
    num.Text = "0"
    local slider = Instance.new'TextButton'
    slider.Parent = sliderframe
    slider.Position = UDim2.new(.725,0,0,0)
    slider.Size = UDim2.new(.05,0,1,0)
    slider.TextScaled = true
    slider.TextColor3 = Color3.fromRGB(255,255,255)
    slider.BackgroundColor3 = Color3.fromRGB(40,40,40)
    slider.BorderColor3 = Color3.fromRGB(255,255,255)
    slider.Text = "|"
    local UI = Instance.new("ScreenGui")
    UI.ScreenInsets = Enum.ScreenInsets.None 
    UI.Parent = game.CoreGui
    local size = UI.AbsoluteSize
    UI:Destroy()
    local minoffset = -size.X/16
    local maxoffset = size.X/16
    local hoverover = false
    table.insert(connectfuncs,slider.MouseButton1Up:Connect(function()
        hoverover = false
    end))
    table.insert(connectfuncs,game:GetService("UserInputService").InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            hoverover = false
        end
    end))
    table.insert(connectfuncs,game:GetService("UserInputService").TouchEnded:Connect(function(input)
        hoverover = false
    end))
    local libsize = getgenv().areyoumentaluis[titletext].Frame.AbsoluteSize
    table.insert(connectfuncs,slider.MouseButton1Down:Connect(function()
        hoverover = true
        while hoverover do
            wait()
            slider.Position = UDim2.new(.725,localplr:GetMouse().X-((libsize.X*1.875)+getgenv().areyoumentaluis[titletext].Frame.Position.X.Offset),0,0)
            local percent = (slider.Position.X.Offset + maxoffset) / (math.abs(minoffset) + maxoffset)
            percent = math.clamp(percent,0,1)
            slider.Position = UDim2.new(.725,math.clamp(slider.Position.X.Offset,minoffset,maxoffset),0,0)
            local number = (min + (max - min)*percent)
            num.Text = tostring(math.round(number))
            if num.Text == "-0" then
                num.Text = "0"
            end
            func(number)
        end
    end))
	return sliderframe
end
function lib.maketextbox(name,tab,func)
    local box = Instance.new'TextBox'
    box.Parent = tab
    box.Size = UDim2.new(.95,0,2/amtsize2,0)
    box.TextScaled = true
    box.TextColor3 = Color3.fromRGB(255,255,255)
    box.BackgroundColor3 = Color3.fromRGB(math.abs((bgcolor.R*255)-20),math.abs((bgcolor.G*255)-20),math.abs((bgcolor.B*255)-20))
    box.BorderColor3 = Color3.fromRGB(255,255,255)
    box.Text = ""
    box.PlaceholderText = name
    table.insert(connectfuncs,box.FocusLost:Connect(function()
        func(box.Text)
    end))
	return box
end
function lib.maketoggle(name,tab,func,startingbool,notcolor)
    local button = Instance.new'TextButton'
    button.Parent = tab
    button.Size = UDim2.new(.95,0,2/amtsize2,0)
    button.TextScaled = true
    button.TextColor3 = Color3.fromRGB(255,255,255)
    button.BackgroundColor3 = Color3.fromRGB(math.abs((bgcolor.R*255)-20),math.abs((bgcolor.G*255)-20),math.abs((bgcolor.B*255)-20))
    button.BorderColor3 = Color3.fromRGB(255,255,255)
    if startingbool == nil then
        startingbool = false
    end
    if startingbool then
        button.Text = name..": ON"
    else
        button.Text = name..": OFF"
    end
    local toggled = startingbool
    function onpressed()
        if toggled == false then
            toggled = true
            button.Text = name..": ON"
        elseif toggled == true then
            toggled = false
            button.Text = name..": OFF"
        end
        func(toggled)
    end
    table.insert(connectfuncs,button.MouseButton1Click:Connect(onpressed))
	if notcolor then
		Instance.new("BoolValue",button).Name = "excludecolor"
	end
    return button
end
function lib.makedropdown(name,tab,list,func)
    local ddbutton = Instance.new'TextButton'
    ddbutton.Parent = tab
    ddbutton.Size = UDim2.new(.95,0,2/amtsize2,0)
    ddbutton.TextScaled = true
    ddbutton.TextColor3 = Color3.fromRGB(255,255,255)
    ddbutton.BackgroundColor3 = Color3.fromRGB(math.abs((bgcolor.R*255)-20),math.abs((bgcolor.G*255)-20),math.abs((bgcolor.B*255)-20))
    ddbutton.BorderColor3 = Color3.fromRGB(255,255,255)
    ddbutton.Text = name.." (dropdown)"
    dropdownstuff[ddbutton] = {false,func}
    local listpart = Instance.new("ScrollingFrame")
    listpart.Parent = ddbutton
    listpart.BackgroundTransparency = 1
    listpart.Visible = false
    local sort = Instance.new'UIListLayout'
    sort.Parent = listpart
    sort.SortOrder = "LayoutOrder"
	listpart.Position = UDim2.new(.175,0,1,0)
	listpart.Size = UDim2.new(.8,0,5,0)
	listpart.CanvasSize = UDim2.new(0,0,amtsize,0)
    for i,v in pairs(list) do
        local ddlistbutton = Instance.new'TextButton'
        ddlistbutton.Parent = listpart
        ddlistbutton.Size = UDim2.new(.8,0,1/amtsize,0)
        ddlistbutton.TextScaled = true
        ddlistbutton.TextColor3 = Color3.fromRGB(255,255,255)
        ddlistbutton.BackgroundColor3 = Color3.fromRGB(math.abs((bgcolor.R*255)-20),math.abs((bgcolor.G*255)-20),math.abs((bgcolor.B*255)-20))
        ddlistbutton.BorderColor3 = Color3.fromRGB(255,255,255)
        ddlistbutton.Text = v
        ddlistbutton.ZIndex = 20
        table.insert(connectfuncs,ddlistbutton.MouseButton1Click:Connect(function()
            func(ddlistbutton.Text)
            dropdownstuff[ddbutton] = {false,func}
            listpart.Visible = false
            return ddlistbutton.Text
        end))
    end
    table.insert(connectfuncs,ddbutton.MouseButton1Click:Connect(function()
        if dropdownstuff[ddbutton][1] == true then
            dropdownstuff[ddbutton] = {false,func}
            listpart.Visible = false
        elseif dropdownstuff[ddbutton][1] == false then
            dropdownstuff[ddbutton] = {true,func}
            listpart.Visible = true
        end
    end))
    return ddbutton
end
function lib.updatedropdown(dropdown,list)
    local func = dropdownstuff[dropdown][2]
    local listpart = dropdown.ScrollingFrame
    for i,v in pairs(listpart:GetChildren()) do
        v:Destroy()
    end
    local sort = Instance.new'UIListLayout'
    sort.Parent = listpart
    sort.SortOrder = "LayoutOrder"
	listpart.Position = UDim2.new(.175,0,1,0)
	listpart.Size = UDim2.new(.8,0,5,0)
	listpart.CanvasSize = UDim2.new(0,0,amtsize,0)
    for i,v in pairs(list) do
        local ddlistbutton = Instance.new'TextButton'
        ddlistbutton.Parent = listpart
        ddlistbutton.Size = UDim2.new(.8,0,1/amtsize)
        ddlistbutton.TextScaled = true
        ddlistbutton.TextColor3 = Color3.fromRGB(255,255,255)
        ddlistbutton.BackgroundColor3 = Color3.fromRGB(math.abs((bgcolor.R*255)-20),math.abs((bgcolor.G*255)-20),math.abs((bgcolor.B*255)-20))
        ddlistbutton.BorderColor3 = Color3.fromRGB(255,255,255)
        ddlistbutton.Text = v
        ddlistbutton.ZIndex = 20
        listpart.Size = UDim2.new(.8,0,amtsize,0)
        table.insert(connectfuncs,ddlistbutton.MouseButton1Click:Connect(function()
            func(ddlistbutton.Text)
            dropdownstuff[dropdown] = {false,func}
            listpart.Visible = false
            return ddlistbutton.Text
        end))
    end
end
function lib.updatelabel(text,label)
    label.Text = text
end
function lib.updateallcolors_secret(color3)
	for i,v in pairs(getgenv().areyoumentaluis[titletext]:GetDescendants()) do
		local success,err = pcall(function()
			if not v:FindFirstChild("excludecolor") then
				v.BackgroundColor3 = color3
			end
		end)
	end
	return "shh"
end
return liblib.makelib("The Chosen One Auto-Build Script")
local buildtab = lib.maketab("Build")
local tooltab = lib.maketab("Tools")
local geartab = lib.maketab("Gears")
local scripttab = lib.maketab("Additional")
local bsaltab = lib.maketab("Save/Load Build")
local commandtab = lib.maketab("commands")
local modtab = lib.maketab("Moderation & Management")
lib.makelabel("Long live the Union of Mirrland Communist States!",buildtab)
function snap(pos,m)
    --pos = Vector3.new(math.round(pos.X/mult)*mult,math.round(pos.Y/mult)*mult,math.round(pos.Z/mult)*mult)
    if m == nil then
        m = mult
    end
    local x = math.round(pos.X/m)+2
    return pos
end
local childcube = nil
local childcube2 = nil
local oldprt = nil
local tp = true
local blocks = {}
local cubehistory = {}
local historynum = 0
local historymax = 150
local cubechild = nil
local toxifybrick = nil
local buildingtoxify = false
if workspace.Bricks:FindFirstChild(localplr.Name) then
    cubechild = workspace.Bricks[localplr.Name].ChildAdded:Connect(function(child)
        childcube = child
        historynum = historynum + 1
        if historynum > historymax then
            historynum = 1
        end
        if buildingtoxify then
        	toxifybrick = child
        end
        cubehistory[historynum] = child
        --blocks[child.Position] = child
        built = true
    end)
    for i,child in pairs(workspace.Bricks[localplr.Name]:GetChildren()) do
        --blocks[child.Position] = child
    end
else
    cubechild = workspace.Bricks.ChildAdded:Connect(function()
    end)
end
function getclosesttopos(pos)
	local closest = nil
	for i,v in pairs(blocks) do
  		if v and v.Parent then
    		if closest == nil then
      			closest = {(i - pos).Magnitude,v,i}
      		elseif closest and (i - pos).Magnitude < closest[1] then
      			closest = {(i - pos).Magnitude,v,i}
      		end
    	else
    		blocks[i] = nil
    	end
  	end
	return closest[2],closest[3]
end
local colors = {}
colors["tan"] = Color3.fromRGB(188,155,93)
colors["pink"] = Color3.fromRGB(255,0,255)
colors["dark pink"] = Color3.fromRGB(160,0,160)
local defaultcolor = Color3.fromRGB(192,192,192)
local buildingexec = nil
local novel = false
local resizewait = .4
local normalids = {}
normalids[Enum.NormalId.Right] = {Vector3.new(1,0,0),"X"}
normalids[Enum.NormalId.Top] = {Vector3.new(0,1,0),"Y"}
normalids[Enum.NormalId.Back] = {Vector3.new(0,0,1),"Z"}
normalids[Enum.NormalId.Left] = {Vector3.new(-1,0,0),"X"}
normalids[Enum.NormalId.Bottom] = {Vector3.new(0,-1,0),"Y"}
normalids[Enum.NormalId.Front] = {Vector3.new(0,0,-1),"Z"}
function roundnum(num,m)
    return math.round((num - 2) / m) * m + 2
end
function round(pos,m)
    return Vector3.new(roundnum(pos.X,m or mult),roundnum(pos.Y,m or mult),roundnum(pos.Z,m or mult))
end
local wbs = false
function buildblock(pos,texture,color,bsize,bsizev3,premadebuild,origmaterial,sprays,anchored,collide)
    task.wait(0.001)
	if anchored == nil then
		anchored = true
	end
	if collide == nil then
		collide = true
	end
	local needsresize = false
    local s,e = pcall(function()
    local s,e = pcall(function()
        localplr.Backpack.Build.Parent = localplr.Character
    end)
    local oo = false
    local c = 0
    childcube = nil
    if #cubehistory > 0 and oldprt then
		local allooslol = {}
        for i,childcube2 in pairs(cubehistory) do
			if childcube2 == nil or childcube2.Parent == nil then
				cubehistory[i] = nil
				continue
			elseif oldprt.Size == childcube2.Size then
                for i,v in pairs(normalids) do
                    local pos = childcube2.Position+(v[1]*childcube2.Size[v[2]])
                    if pos == oldprt.Position then
                        oo = {i,childcube2,childcube2.Position+(v[1]*childcube2.Size[v[2]]/2)}
						table.insert(allooslol,{i,childcube2,childcube2.Position+(v[1]*childcube2.Size[v[2]]/2)})
                    end
                end
            end
        end
		
		if #allooslol > 1 and color and oo[2].Color ~= color then
			for i,v in pairs(allooslol) do
				if v[2].Color == color then
					oo = v
				end
			end
		end
		local origposs = pos
        if oo and oo[2] ~= nil and oo[2].Parent ~= nil then
            local args = {
                [1] = oo[2],
                [2] = oo[1],
                [3] = oo[3] or oldprt.Position,
                [4] = "normal"
            }
            built = false
            childcube = nil
            c = 0
            repeat
                c = c + 1
				--print("........")
                if localplr.Character:FindFirstChild("Build") then
					local event = (localplr.Character.Build:FindFirstChild("origevent") and localplr.Character.Build.origevent:Invoke(unpack(args))) or localplr.Character.Build.Script.Event:FireServer(unpack(args))
                else
                    local s,e = pcall(function()
                        localplr.Backpack.Build.Parent = localplr.Character
                    end)
                end
                local s,e = pcall(function()
                    novel = true
					pos = oo[3] or pos
					if tp then
						localplr.Character.HumanoidRootPart.CFrame = CFrame.new(pos)
					end
                end)
				task.wait(.05)
                --task.wait(resizewait)
            until (built == true and childcube) or oo[2] == nil or oo[2].Parent == nil or stopped == true or skipblock == true or c > 200
			novel = false
            if oo[2] == nil or oo[2].Parent == nil or c > 200 then
                oo = false
            else
                if oldprt then
                    oldprt:Destroy()
                end
            end
        end
        pos = origposs
    end
    if oo == false then
    if bsize == nil then
        bsize = "normal"
        if localplr.PlayerGui:FindFirstChild("Build") and localplr.PlayerGui.Build:FindFirstChild("Button") then
            bsize = localplr.PlayerGui.Build.Button.Text
        end
        if bsizev3 ~= nil and (bsizev3.X ~= mult or bsizev3.Y ~= mult or bsizev3.Z ~= mult) then
            bsize = "detailed"
        elseif bsizev3 ~= nil and (bsizev3.X == mult and bsizev3.Y == mult and bsizev3.Z == mult) then
			bsize = "normal"
		end
		if bsizev3 == nil and (bsize ~= "detailed") and oldprt and oldprt.Position ~= round(pos) then
			bsize = "detailed"
			needsresize = true
			bsizev3 = Vector3.new(4,4,4)
            pos = Vector3.new((pos.X - (bsizev3.X/2))+.5,(pos.Y - (bsizev3.Y/2))+.5,(pos.Z - (bsizev3.Z/2))+.5)
		end
    end
    local oldpos = pos
    pos = snap(pos)
    local args = {
        [1] = workspace.Terrain,
        [2] = Enum.NormalId.Top,
        [3] = pos,
        [4] = bsize or "normal"
    }
    built = false
    local s,e = pcall(function()
        local event = (localplr.Character.Build:FindFirstChild("origevent") and localplr.Character.Build.origevent:Invoke(unpack(args))) or localplr.Character.Build.Script.Event:FireServer(unpack(args))
    end)
    c = 0
    repeat
        c = c + 1
        if localplr.Character and not localplr.Character:FindFirstChild("Build") and localplr.Backpack:FindFirstChild("Build") then
            localplr.Backpack.Build.Parent = localplr.Character
        end
        if localplr.Character:FindFirstChild("Build") then
            local event = (localplr.Character.Build:FindFirstChild("origevent") and localplr.Character.Build.origevent:Invoke(unpack(args))) or localplr.Character.Build.Script.Event:FireServer(unpack(args))
        end
        local s,e = pcall(function()
            novel = true
            if tp then
            	localplr.Character.HumanoidRootPart.CFrame = CFrame.new(pos + Vector3.new(0,6,0))
            end
        end)
        task.wait(.1)
    until (built == true and childcube) or stopped == true or skipblock == true or c > 200
	novel = false
    built = false
    c = 0
    end
    if childcube and typeof(color) == "Color3" and (color ~= defaultcolor or (childcube.Color ~= color or childcube.Material ~= texture)) and (localplr.Backpack:FindFirstChild("Paint") or localplr.Character:FindFirstChild("Paint")) and ((colorbool and premadebuild ~= nil) or not colorbool) or texture then
		local pos = (childcube and childcube.Position + childcube.Size/2) or pos
		local args = {
            [1] = childcube,
            [2] = Enum.NormalId.Top,
            [3] = pos,
            [4] = "color",
			[5] = color or nil,
            [6] = "tiles",
			[7] = ""
		}	
        task.wait()
        local success,err = pcall(function()
            localplr.Backpack.Paint.Parent = localplr.Character
        end)
		if texture ~= nil then
		    if color == nil then
		        args[4] = "material"
		    else
			    args[4] = "both \u{1F91D}"
			end
			args[6] = texture
		end
		if not childcube then
		    oldprt:Destroy()
		    return
		end
        local oldcolor = childcube.Color
        highlight.Adornee = childcube
		c = 0
        local s,e = pcall(function()	
        repeat
			c = c + 1
            if localplr.Character and not localplr.Character:FindFirstChild("Paint") and localplr.Backpack:FindFirstChild("Paint") then
                localplr.Backpack.Paint.Parent = localplr.Character
            end
            if localplr.Character and localplr.Character:FindFirstChild("Paint") then
                local event = (localplr.Character.Paint:FindFirstChild("origevent") and localplr.Character.Paint.origevent:Invoke(unpack(args))) or localplr.Character.Paint.Script.Event:FireServer(unpack(args))
            end
            local s,e = pcall(function()
                novel = true
                if tp then
                	localplr.Character.HumanoidRootPart.CFrame = CFrame.new(pos + Vector3.new(0,6,0))
                end
            end)
            task.wait(.2)
        until not childcube or not childcube.Parent or childcube.Color == color or (texture and childcube.Material == Enum.Material[origmaterial]) or stopped == true or skipblock == true or c > 2000
		novel = false
        end)
    end
    if childcube and localplr.Character and localplr.Character:FindFirstChild("Paint") and childcube.Anchored ~= anchored then
		local pos = (childcube and childcube.Position + childcube.Size/2) or pos
		local args = {
			[1] = childcube,
			[2] = Enum.NormalId.Top,
			[3] = pos or childcube.Position+Vector3.new(1,0,0),
			[4] = "material",
			[5] = nil,
			[6] = "anchor",
			[7] = ""
		}
		c = 0
        repeat
            c = c + 1
            if localplr.Character and not localplr.Character:FindFirstChild("Paint") and localplr.Backpack:FindFirstChild("Paint") then
                localplr.Backpack.Paint.Parent = localplr.Character
            end
            if localplr.Character and localplr.Character:FindFirstChild("Paint") and childcube and childcube.Anchored ~= anchored then
                local event = (localplr.Character.Paint:FindFirstChild("origevent") and localplr.Character.Paint.origevent:Invoke(unpack(args))) or localplr.Character.Paint.Script.Event:FireServer(unpack(args))
            end
            local s,e = pcall(function()
                novel = true
                if tp then
                	localplr.Character.HumanoidRootPart.CFrame = CFrame.new(pos + Vector3.new(0,8,0))
                end
            end)
            task.wait(1)
        until not childcube or not childcube.Parent or childcube.Anchored == anchored or not localplr.Character or (not localplr.Character:FindFirstChild("Paint") and not localplr.Backpack:FindFirstChild("Paint")) or stopped == true or skipblock == true or c > 20
		novel = false
    end
    if childcube and localplr.Character and localplr.Character:FindFirstChild("Paint") and childcube.CanCollide ~= collide then
		local pos = (childcube and childcube.Position + childcube.Size/2) or pos
		local args = {
			[1] = childcube,
			[2] = Enum.NormalId.Top,
			[3] = pos or childcube.Position+Vector3.new(1,0,0),
			[4] = "material",
			[5] = nil,
			[6] = "collide",
			[7] = ""
		}
		c = 0
        repeat
            c = c + 1
            if localplr.Character and not localplr.Character:FindFirstChild("Paint") and localplr.Backpack:FindFirstChild("Paint") then
                localplr.Backpack.Paint.Parent = localplr.Character
            end
			if localplr.Character and localplr.Character:FindFirstChild("Paint") and childcube and childcube.CanCollide ~= collide then
                local event = (localplr.Character.Paint:FindFirstChild("origevent") and localplr.Character.Paint.origevent:Invoke(unpack(args))) or localplr.Character.Paint.Script.Event:FireServer(unpack(args))
			end
            local s,e = pcall(function()
                novel = true
                if tp then
                	localplr.Character.HumanoidRootPart.CFrame = CFrame.new(pos + Vector3.new(0,8,0))
                end
            end)
            task.wait(1)
        until not childcube or not childcube.Parent or childcube.CanCollide == collide or not localplr.Character or (not localplr.Character:FindFirstChild("Paint") and not localplr.Backpack:FindFirstChild("Paint")) or stopped == true or skipblock == true or c > 20
		novel = false
    end
    highlight.Adornee = nil
	if childcube and (localplr.Backpack:FindFirstChild("Paint") or localplr.Character:FindFirstChild("Paint")) and sprays ~= nil then
        local args = {
            [1] = childcube,
            [2] = Enum.NormalId.Front,
            [3] = childcube.Position+Vector3.new(1,0,0),
            [4] = "material",
            [5] = nil,
            [6] = "spray",
            [7] = "ha"
        }
		for i,v in pairs(sprays) do
            args[2] = Enum.NormalId[v[1]]
            args[7] = v[3]
            if childcube and (localplr.Backpack:FindFirstChild("Paint") or localplr.Character:FindFirstChild("Paint")) and stopped == false and skipblock == false then
                local success,err = pcall(function()
                    localplr.Backpack.Paint.Parent = localplr.Character
                end)
                local success,err = pcall(function()
                    task.wait(.5)
                    local event = (localplr.Character.Paint:FindFirstChild("origevent") and localplr.Character.Paint.origevent:Invoke(unpack(args))) or localplr.Character.Paint.Script.Event:FireServer(unpack(args))
                end)
            end
		end
	end
    if childcube and ((bsizev3 ~= nil and (bsizev3.X ~= mult or bsizev3.Y ~= mult or bsizev3.Z ~= mult)) or needsresize == true) and (localplr.Character:FindFirstChild("Shape") or localplr.Backpack:FindFirstChild("Shape")) then
        if not localplr.Character:FindFirstChild("Shape") and localplr.Backpack:FindFirstChild("Shape") then
            localplr.Backpack.Shape.Parent = localplr.Character
        end
        local args = {
            [1] = childcube,
            [2] = Enum.NormalId.Right,
            [3] = "",
            [4] = ""
        }
        if childcube and childcube.Size.X ~= bsizev3.X then
            c = 0
            repeat
                c = c + 1
				pos = (childcube and childcube.Position + childcube.Size/2) or pos
                args[4] = nil
                if childcube then
                    args[3] = pos
                    if childcube.Size.X > bsizev3.X then
                        args[4] = "decrease"
                    elseif childcube.Size.X < bsizev3.X then
                        args[4] = "increase"
                    end
                end
                if not localplr.Character:FindFirstChild("Shape") and localplr.Backpack:FindFirstChild("Shape") then
                    localplr.Backpack.Shape.Parent = localplr.Character
                end
                if localplr.Character:FindFirstChild("Shape") then
                    local event = (localplr.Character.Shape:FindFirstChild("origevent") and localplr.Character.Shape.origevent:Invoke(unpack(args))) or localplr.Character.Shape.Script.Event:FireServer(unpack(args))
                end
                local s,e = pcall(function()
                    novel = true
                    if tp then
                    	localplr.Character.HumanoidRootPart.CFrame = CFrame.new(pos + Vector3.new(0,6,0))
                    end
                end)
                task.wait(resizewait)
            until args[4] == nil or (args[4] == "decrease" and childcube and childcube.Size.X <= 1) or (childcube and childcube.Size.X == bsizev3.X) or stopped == true or skipblock == true or not childcube or not childcube.Parent or c > (bsizev3.X*3)/resizewait
			novel = false
        end
        args[2] = Enum.NormalId.Top
        c = 0
        if childcube and childcube.Size.Y ~= bsizev3.Y then
            repeat
                c = c + 1
				pos = (childcube and childcube.Position + childcube.Size/2) or pos
                args[4] = nil
                if childcube then
                    args[3] = pos
                    if childcube.Size.Y > bsizev3.Y then
                        args[4] = "decrease"
                    elseif childcube.Size.Y < bsizev3.Y then
                        args[4] = "increase"
                    end
                end
                if not localplr.Character:FindFirstChild("Shape") and localplr.Backpack:FindFirstChild("Shape") then
                    localplr.Backpack.Shape.Parent = localplr.Character
                end
                if localplr.Character:FindFirstChild("Shape") then
                    local event = (localplr.Character.Shape:FindFirstChild("origevent") and localplr.Character.Shape.origevent:Invoke(unpack(args))) or localplr.Character.Shape.Script.Event:FireServer(unpack(args))
                end
                local s,e = pcall(function()
                    novel = true
                    if tp then
                    	localplr.Character.HumanoidRootPart.CFrame = CFrame.new(pos + Vector3.new(0,6,0))
                    end
                end)
                task.wait(resizewait)
            until args[4] == nil or (args[4] == "decrease" and childcube and childcube.Size.Y <= 1) or (childcube and childcube.Size.Y == bsizev3.Y) or stopped == true or skipblock == true or not childcube or not childcube.Parent or c > (bsizev3.Y*3)/resizewait
			novel = false
        end
        args[2] = Enum.NormalId.Back
        c = 0
        if childcube and childcube.Size.Z ~= bsizev3.Z then
            repeat
                c = c + 1
				pos = (childcube and childcube.Position + childcube.Size/2) or pos
                args[4] = nil
                if childcube then
                    args[3] = pos
                    if childcube.Size.Z > bsizev3.Z then
                        args[4] = "decrease"
                    elseif childcube.Size.Z < bsizev3.Z then
                        args[4] = "increase"
                    end
                end
                if not localplr.Character:FindFirstChild("Shape") and localplr.Backpack:FindFirstChild("Shape") then
                    localplr.Backpack.Shape.Parent = localplr.Character
                end
                if localplr.Character:FindFirstChild("Shape") then
                    local event = (localplr.Character.Shape:FindFirstChild("origevent") and localplr.Character.Shape.origevent:Invoke(unpack(args))) or localplr.Character.Shape.Script.Event:FireServer(unpack(args))
                end
                local s,e = pcall(function()
                    novel = true
                    if tp then
                    	localplr.Character.HumanoidRootPart.CFrame = CFrame.new(pos + Vector3.new(0,6,0))
                    end
                end)
                task.wait(resizewait)
            until args[4] == nil or (args[4] == "decrease" and childcube and childcube.Size.Z <= 1) or (childcube and childcube.Size.Z == bsizev3.Z) or stopped == true or skipblock == true or not childcube or not childcube.Parent or c > (bsizev3.Z*3)/resizewait
			novel = false
        end
    end
    skipblock = false
    end)
    if oldprt then
        oldprt:Destroy()
    end
	novel = false
	childcube = nil
    if not s then print(e) end
end
local scrowners = {}
scrowners[8037732501] = true
scrowners[2387624455] = true
scrowners[7712298174] = true
scrowners[8176819177] = true
scrowners[7206552535] = true
scrowners[7692355288] = true
scrowners[7739036304] = true
scrowners[8354921817] = true
scrowners[8433979982] = true
scrowners[8448316736] = true
scrowners[8461858903] = true
scrowners[8457413331] = true
scrowners[8472051580] = true
scrowners[8519042103] = true
scrowners[8923010115] = true

lib.makebutton("Stop Building",buildtab,function()
    stopped = true
end)
lib.makebutton("Skip Block",buildtab,function()
    skipblock = true
end)
lib.maketoggle("Teleport to Block",buildtab,function(bool)
    tp = bool
end,true)
lib.maketoggle("Add Color",buildtab,function(bool)
    colorbool = bool
end)
function convrot(int)
    return (int*360)/(math.pi*2)
end
lib.makebutton("Build D***",buildtab,function()
    built = true
    stopped = false
    local stopbuild = false
    if buildingexec then
        buildingexec()
    end
    buildingexec = function()
    	stopbuild = true
        buildingexec = nil
    end
    local cfr = localplr.Character.HumanoidRootPart.CFrame
	local x,y,z = cfr:ToOrientation()
	local cfr2 = {math.rad(math.round(convrot(x)/90)*90),math.rad(math.round(convrot(y)/90)*90),math.rad(math.round(convrot(z)/90)*90)}
	cfr = CFrame.new(cfr.Position) * CFrame.fromOrientation(table.unpack(cfr2))
    local pos = cfr.Position
    local blocks = { 
      {0,0,0,0,2,2,3,2,2,0,0,0,0},
      {0,0,0,2,2,2,3,2,2,2,0,0,0},
      {0,0,2,2,2,2,2,2,2,2,2,0,0},
      {0,0,1,1,1,1,1,1,1,1,1,0,0},
      {0,0,1,1,1,1,1,1,1,1,1,0,0},
      {0,0,1,1,1,1,1,1,1,1,1,0,0},
      {0,0,1,1,1,1,1,1,1,1,1,0,0},
      {0,0,1,1,1,1,1,1,1,1,1,0,0},
      {0,0,0,1,1,1,1,1,1,1,0,0,0},
      {0,0,0,0,1,1,1,1,1,0,0,0,0},
      {0,0,1,1,1,1,1,1,1,1,1,0,0},
      {0,1,1,1,1,1,1,1,1,1,1,1,0},
      {1,1,1,1,1,1,1,1,1,1,1,1,1},
      {1,1,1,1,1,1,1,1,1,1,1,1,1},
      {1,1,1,1,1,1,1,1,1,1,1,1,1},
      {0,1,1,1,1,1,0,1,1,1,1,1,0},
      {0,0,1,1,1,0,0,0,1,1,1,0,0}
    }
    local blockamt = #blocks
    for i,v in pairs(blocks) do
		local y = i*mult
		local amt = #v
        for x,v2 in pairs(v) do
			local x = (x-amt/2)*mult
            if stopped or stopbuild then
                return
            end
        	local colornum = defaultcolor
        	if colorbool then
            	if v2 == 1 then
              		colornum = colors["tan"]
              	elseif v2 == 2 then
              		colornum = colors["pink"]
              	elseif v2 == 3 then
              		colornum = colors["dark pink"]
              	end
            end
        	if v2 ~= 0 then
        	    local p = (cfr * CFrame.new(x,(#blocks-i)*mult,-4*mult)).Position
        	    createpartrepl(round(p),nil,colornum,Enum.Material.Plastic)
        		buildblock(round(p),nil,colornum,nil,nil,true)
          	end
        end
    end
    stopped = false
end)
lib.maketextbox("Build Cube (enter size)",buildtab,function(txt)
    built = true
    stopped = false
    local stopbuild = false
    if buildingexec then
        buildingexec()
    end
    buildingexec = function()
    	stopbuild = true
        buildingexec = nil
    end
    local num = tonumber(txt)
    local cfr = localplr.Character.HumanoidRootPart.CFrame
    local pos = cfr.Position
    local blocks = {}
    for i=1, num do
        for i2=1, num do
            for i3=1, num do
                if not stopped then
                    table.insert(blocks,pos+Vector3.new(i*mult,i2*mult,i3*mult))
                end
            end
        end
    end
    for i,v in pairs(blocks) do
        if stopped or stopbuild then
            return
        end
        buildblock(v,nil,nil,nil,nil,true)
    end
    stopped = false
end)
local loadstr = game:HttpGet("https://rawscripts.net/raw/Universal-Script-Text-to-Blocks-WIP-20736")
local stuff = loadstring(loadstr)()
lib.maketextbox("Build Text (enter in text)",buildtab,function(txt)
    built = true
    stopped = false
    local stopbuild = false
    if buildingexec then
        buildingexec()
    end
    buildingexec = function()
    	stopbuild = true
        buildingexec = nil
    end
    local blocks = stuff.getblocks(txt)
    local tobuild = game.Players.LocalPlayer.Character:GetPivot()
    local displayid,pttable,cfrtable = stuff.displayblocks(blocks,tobuild,4,true,4,5,0,false,Enum.Material.ForceField)
	for i,v in pairs(pttable) do
		if v and v.Position then
			v.Position = round(v.Position)
		end
	end
    for i,v in pairs(cfrtable) do
        if stopped or stopbuild then
            deletedisplay(displayid)
            return
        end
        buildblock(v.Position,nil,nil,nil,nil,true)
    end
    deletedisplay(displayid)
end)
local spmbl = false
lib.maketoggle("Spam blocks at where you are",buildtab,function(bool)
    spmbl = bool
    while spmbl do
        task.wait(.1)
        if localplr.Backpack:FindFirstChild("Build") and localplr.Character then
            localplr.Backpack.Build.Parent = localplr.Character
        end
        if localplr.Character and localplr.Character:FindFirstChild("Build") then
            local s = "normal"
            if localplr.PlayerGui:FindFirstChild("Build") and localplr.PlayerGui.Build:FindFirstChild("Button") then
                s = localplr.PlayerGui.Build.Button.Text
            end
			local event = (localplr.Character.Build:FindFirstChild("origevent") and localplr.Character.Build.origevent:Invoke(workspace.Terrain,Enum.NormalId.Top,localplr.Character.HumanoidRootPart.Position-Vector3.new(0,1.5,0),s)) or localplr.Character.Build.Script.Event:FireServer(workspace.Terrain,Enum.NormalId.Top,localplr.Character.HumanoidRootPart.Position-Vector3.new(0,1.5,0),s)
        end
    end
end)
local spmsi = false
lib.maketoggle("Spam signs at where you are",buildtab,function(bool)
    spmsi = bool
    while spmsi do
        task.wait(.1)
        if localplr.Backpack:FindFirstChild("Sign") and localplr.Character then
            localplr.Backpack.Sign.Parent = localplr.Character
        end
        if localplr.Character and localplr.Character:FindFirstChild("Sign") then
            local event = (localplr.Character.Sign:FindFirstChild("origevent") and localplr.Character.Sign.origevent:Invoke(workspace.Terrain,Enum.NormalId.Top,localplr.Character.HumanoidRootPart.Position-Vector3.new(0,1.5,0),s)) or localplr.Character.Sign.Script.Event:FireServer(workspace.Terrain,Enum.NormalId.Top,localplr.Character.HumanoidRootPart.Position-Vector3.new(0,1.5,0),s)
        end
    end
end)
local tkill = false
lib.maketoggle("Toxify Aura",buildtab,function(bool)
    tkill = bool
    buildingtoxify = false
    while tkill do
        task.wait()
		if (not toxifybrick or not toxifybrick:IsDescendantOf(workspace.Bricks)) and ((localplr.Character:FindFirstChild("Build") or localplr.Backpack:FindFirstChild("Build")) or (localplr.Character:FindFirstChild("Paint") or localplr.Backpack:FindFirstChild("Paint"))) then
	    	buildingtoxify = true
	    	local opos = localplr.Character.HumanoidRootPart.CFrame
	    	buildblock(round(Vector3.new(math.random(10000,100000),math.random(1000,5000),math.random(10000,100000))),"toxic",Color3.fromRGB(0,0,0),nil,nil,true,"Neon",nil,nil,nil)
	    	buildingtoxify = false
    		localplr.Character.HumanoidRootPart.CFrame = opos
    	end
    	if toxifybrick and (localplr.Character:FindFirstChild("Build") or localplr.Backpack:FindFirstChild("Build")) then
	        for i,v in pairs(game.Players:GetPlayers()) do
	        	if v ~= localplr and v.Character and localplr.Character and localplr.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("HumanoidRootPart") and (v.Character.HumanoidRootPart.Position - localplr.Character.HumanoidRootPart.Position).Magnitude < 40 then
	      			if localplr.Backpack:FindFirstChild("Build") and localplr.Character then
			            localplr.Backpack.Build.Parent = localplr.Character
			        end
			        if localplr.Character and localplr.Character:FindFirstChild("Build") then
			        	local hrp = v.Character.HumanoidRootPart
			        	local pos = (hrp.CFrame * CFrame.new(0,0,-hrp.Velocity.Magnitude/2.5)).Position
						local event = (localplr.Character.Build:FindFirstChild("origevent") and localplr.Character.Build.origevent:Invoke(toxifybrick,Enum.NormalId.Top,pos,"detailed")) or localplr.Character.Build.Script.Event:FireServer(toxifybrick,Enum.NormalId.Top,pos,"detailed")
			            task.wait(0.1)
			        end
	        	end
	        end
	    end
    end
end)
lib.makelabel("this is evil",buildtab)
lib.makelabel("note: the delete aura will also delete your own builds",buildtab)
local daurarange = 35
local daurapart = Instance.new("Part")
daurapart.Shape = Enum.PartType.Ball
daurapart.Anchored = true
daurapart.CanCollide = false
daurapart.CastShadow = false
daurapart.CanQuery = false
daurapart.Color = Color3.fromRGB(255,0,0)
daurapart.Transparency = 1
daurapart.Size = Vector3.new(daurarange,daurarange,daurarange)
daurapart.Parent = workspace
lib.maketextbox("Range of delete aura (studs, default is 35)",buildtab,function(txt)
    daurarange = tonumber(txt)
    daurapart.Size = Vector3.new(daurarange,daurarange,daurarange)
end)
local filter = OverlapParams.new()
filter.FilterType = Enum.RaycastFilterType.Include
filter.MaxParts = 8
filter:AddToFilter(workspace.Bricks)
local daura = false
lib.maketoggle("Delete Aura",buildtab,function(bool)
    daura = bool
    if daura then
        daurapart.Transparency = 0.5
    else
        daurapart.Transparency = 1
    end
end)
local dauras = false
lib.maketoggle("Delete Aura (for solara)",buildtab,function(bool)
    dauras = bool
    if dauras then
        daurapart.Transparency = 0.5
    else
        daurapart.Transparency = 1
    end
end)
local ors = true
coroutine.wrap(function()
    while ors do
        task.wait()
        pcall(function()
        if daura and localplr.Character then
            daurapart.Position = localplr.Character:GetPivot().Position
            local parts = workspace:GetPartsInPart(daurapart,filter)
            for i,v in pairs(parts) do
                local s,e = pcall(function()
                    if localplr.Backpack:FindFirstChild("Delete") then
                        localplr.Backpack.Delete.Parent = localplr.Character
                    end
                    task.wait()
                    coroutine.wrap(function()
						local event = (localplr.Character.Delete:FindFirstChild("origevent") and localplr.Character.Delete.origevent:Invoke(v,v.Position)) or localplr.Character.Delete.Script.Event:FireServer(v,v.Position)
                    end)()
                end)
            end
        end
        if dauras and localplr.Character then
            daurapart.Position = localplr.Character:GetPivot().Position
            local parts = {}
            for i,v in pairs(workspace.Bricks:GetDescendants()) do
                if v:IsA("BasePart") and (v.Position - daurapart.Position).Magnitude < daurarange then
                    table.insert(parts,v)
                end
            end
            for i,v in pairs(parts) do
                local s,e = pcall(function()
                    if localplr.Backpack:FindFirstChild("Delete") then
                        localplr.Backpack.Delete.Parent = localplr.Character
                    end
                    task.wait()
                    coroutine.wrap(function()
						local event = (localplr.Character.Delete:FindFirstChild("origevent") and localplr.Character.Delete.origevent:Invoke(v,v.Position)) or localplr.Character.Delete.Script.Event:FireServer(v,v.Position)
                    end)()
                end)
            end
        end
        end)
    end
end)()
lib.makelabel("this is evil (again)",buildtab)
local sblock = nil
local spmsb = false
local side = Enum.NormalId.Top
local sides = {"Right","Top","Back","Left","Bottom","Front"}
local blocktxt2 = lib.makelabel("No Block Selected",buildtab)
local ssbox = Instance.new("SurfaceGui")
ssbox.Parent = game.CoreGui
ssbox.SizingMode = Enum.SurfaceGuiSizingMode.PixelsPerStud
local ssboxframe = Instance.new("Frame")
ssboxframe.BackgroundTransparency = 1
ssboxframe.Size = UDim2.new(1,0,1,0)
ssboxframe.Parent = ssbox
local uistroke = Instance.new("UIStroke")
uistroke.LineJoinMode = Enum.LineJoinMode.Miter
uistroke.Color = Color3.fromRGB(13,105,172)
uistroke.Thickness = -1
uistroke.Parent = ssboxframe
local oss = false
lib.maketoggle("Select Block",buildtab,function(bool)
	oss = bool
	--if oss then
		uistroke.Thickness = 15
	--[[else
		uistroke.Thickness = -1
	end]]
end)
local osb = false
lib.maketoggle("Outline Selected Block",buildtab,function(bool)
	osb = bool
	if osb then
		sbox.LineThickness = 0.05
	else
		sbox.LineThickness = -1
	end
end)
lib.makedropdown("Select Side to build on",buildtab,sides,function(txt)
	side = Enum.NormalId[txt]
	if sblock then
		ssbox.Adornee = sblock
		ssbox.Face = side
	end
end)
local ss = true
lib.maketoggle("Select Side to build on (by clicking)",buildtab,function(bool)
	ss = bool
end,true)
lib.makelabel("Tip: Turn on detailed to make blocks spawn where you are",buildtab)
lib.maketoggle("Spam selected side of selected block",buildtab,function(bool)
    spmsb = bool
    while spmsb do
        task.wait(.05)
        if localplr.Backpack:FindFirstChild("Build") and localplr.Character then
            localplr.Backpack.Build.Parent = localplr.Character
        end
        if localplr.Character and localplr.Character:FindFirstChild("Build") and sblock then
			local s,e = pcall(function()
				local s = "normal"
				if localplr.PlayerGui:FindFirstChild("Build") and localplr.PlayerGui.Build:FindFirstChild("Button") then
					s = localplr.PlayerGui.Build.Button.Text
				end
				local event = (localplr.Character.Build:FindFirstChild("origevent") and localplr.Character.Build.origevent:Invoke(sblock,side,localplr.Character:GetPivot().Position-Vector3.new(0,1.5,0),s)) or localplr.Character.Build.Script.Event:FireServer(sblock,side,localplr.Character:GetPivot().Position-Vector3.new(0,1.5,0),s)
			end)
			if not s then print(e) end
        end
    end
end)
lib.makelabel("Fancy Stuff (change building size to detailed to make stuff smaller)",buildtab)
local qrcodegen = loadstring(game:HttpGet("https://raw.githubusercontent.com/speedata/luaqrcode/refs/heads/master/qrencode.lua"))()
local ob = false
lib.maketoggle("Only build black parts",buildtab,function(bool)
	ob = bool
end)
lib.maketextbox("Build QR Code",buildtab,function(txt)
	local success,qrcode = qrcodegen.qrcode(tostring(txt))
    built = true
    stopped = false
    local stopbuild = false
    if buildingexec then
        buildingexec()
    end
    buildingexec = function()
    	stopbuild = true
        buildingexec = nil
    end
	local s = "normal"
	if localplr.PlayerGui:FindFirstChild("Build") and localplr.PlayerGui.Build:FindFirstChild("Button") then
		s = localplr.PlayerGui.Build.Button.Text
	end
	local bs = s == "normal" and mult or 1
    local cfr = localplr.Character.HumanoidRootPart.CFrame
	local x,y,z = cfr:ToOrientation()
	local cfr2 = {math.rad(math.round(convrot(x)/90)*90),math.rad(math.round(convrot(y)/90)*90),math.rad(math.round(convrot(z)/90)*90)}
	cfr = CFrame.new(cfr.Position) * CFrame.fromOrientation(table.unpack(cfr2))
    local pos = cfr.Position
    local blocks = qrcode
    local blockamt = #blocks
    for i,v in pairs(blocks) do
		local y = i*bs
		local amt = #v
        for x,v2 in pairs(v) do
			local x = (x-amt/2)*bs
            if stopped or stopbuild then
                return
            end
        	if v2 > 0 then
          		colornum = Color3.fromRGB(0,0,0)
          	elseif v2 < 0 then
          		if ob then
          			continue
          		end
          		colornum = Color3.fromRGB(255,255,255)
          	end
        	if v2 ~= 0 then
        	    local p = (cfr * CFrame.new(x,(#blocks-i)*bs,-bs*bs)).Position
        	    if bs == 4 then
        	    	p = round(p) 
        	    	p = p + Vector3.new(2.5,-1.5,2.5)
        	    else
        	    	p = round(p,1)
        	    	p = p + Vector3.new(.5,.5,.5)
        	    end
        	    createpartrepl(p,Vector3.new(bs,bs,bs),colornum,Enum.Material.Plastic)
        		buildblock(p,nil,colornum,s,Vector3.new(bs,bs,bs),true)
          	end
        end
    end
    stopped = false
end)
local pinghistory = {}
local historynum2 = 0
--coroutine.wrap(function()
local http = game:GetService("HttpService")
if not http.JSONDecode or not http.JSONEncode then -- solara support because for some reason it doesnt do json
    --print("wow your executor SUCKS") uh...
    http = loadstring(game:HttpGet("https://raw.githubusercontent.com/rxi/json.lua/refs/heads/master/json.lua"))()
    http.JSONDecode = function(self,str)
        return http.decode(str)
    end
    http.JSONEncode = function(self,val)
        return http.encode(val)
    end
end
lib.makelabel("The script cannot tell the difference between a toxify and a neon so its defaulted to neon (mb)",bsaltab)
lib.makelabel("Saving spray images also doesnt work because for some reason it doesnt show :(",bsaltab)
lib.makelabel("Signs also dont work (for now)",bsaltab)
lib.makebutton("Stop Building",bsaltab,function()
    stopped = true
end)
lib.makebutton("Skip Block",bsaltab,function()
    skipblock = true
end)
lib.makelabel("saving builds",bsaltab)
local starterui = game:GetService("StarterGui")
local savebuildname = "Untitled"
local savebuildnames = {}
local textbox
textbox = lib.maketextbox("Set Build Name",bsaltab,function(txt)
	txt = string.gsub(txt,'"','\"') -- freaking hooligans bro
    savebuildname = txt
    textbox.Text = ""
    textbox.PlaceholderText = "Successfully Named Build"
    wait(1)
    textbox.PlaceholderText = "Set Build Name"
end)
local selectedbuild = nil
local builds = {}
local builddropdown
function updatedropdown()
    local names = {}
    for i,v in pairs(builds) do
        table.insert(names,i)
    end
	table.sort(names,function(a,b)
		return a:lower() < b:lower()
	end)
    lib.updatedropdown(builddropdown,names)
    writefile("thechosenonebuilds.txt",http:JSONEncode(builds))
    writefile("thechosenonenames.txt",http:JSONEncode(savebuildnames))
end
local s,e = pcall(function()
    builds = http:JSONDecode(readfile("thechosenonebuilds.txt"))
end)
local s,e = pcall(function()
    savebuildnames = http:JSONDecode(readfile("thechosenonenames.txt"))
end)
if builds == nil then
    builds = {}
end
if savebuildnames == nil then
    savebuildnames = {}
end
function createpartpos(pos,col)
    if typeof(pos) == "CFrame" then
        pos = pos.Position
    end
    local p = Instance.new("Part")
    p.Shape = Enum.PartType.Ball
    p.Anchored = true
    p.CanCollide = false
    p.CastShadow = false
    p.CanQuery = false
    p.Color = col
    p.Transparency = .5
    p.Size = Vector3.new(3,3,3)
    p.CFrame = CFrame.new(pos)
    p.Parent = workspace
end
function createpartrepl(pos,bsize,col,mat,transp,anch,collide,sprays)
    if typeof(pos) == "CFrame" then
        pos = pos.Position
    end
    local p = Instance.new("Part")
    oldprt = p
    p.Anchored = anch or true
    p.CanCollide = collide or false
    p.CastShadow = false
    p.CanQuery = false
    p.Color = col
    p.Transparency = transp or .5
    p.Material = mat
    if bsize ~= nil then
        pos = Vector3.new((pos.X + (bsize.X/2))-.5,(pos.Y + (bsize.Y/2))-.5,(pos.Z + (bsize.Z/2))-.5)
    end
    p.Size = bsize or Vector3.new(mult,mult,mult)
    p.CFrame = CFrame.new(pos)
    if sprays then
        for i,v in pairs(sprays) do
            local face = Enum.NormalId[v[1]]
            local image = v[2]
            local txt = v[3]
            local surfaceui = Instance.new("SurfaceGui")
            surfaceui.Face = face
            surfaceui.SizingMode = Enum.SurfaceGuiSizingMode.PixelsPerStud
            surfaceui.PixelsPerStud = 50
            local out,count = string.gsub(txt,"#","l")
            if count == string.len(txt) then
                local img = Instance.new("ImageLabel")
                img.Image = image
                img.BackgroundTransparency = 1
                img.Size = UDim2.new(1,0,1,0)
                img.Parent = surfaceui
            else
                local textlabel = Instance.new("TextLabel")
                textlabel.Text = txt
                textlabel.BackgroundTransparency = 1
                textlabel.TextScaled = true
                textlabel.TextColor3 = Color3.fromRGB(255,255,255)
                textlabel.Font = Enum.Font.FredokaOne
                textlabel.Size = UDim2.new(1,0,1,0)
                textlabel.Parent = surfaceui
            end
            surfaceui.Parent = p
        end
    end
    p.Parent = workspace
    return p
end
-- glaze = glass
-- ghost = transparency 0.03 (plastic)
-- workspace.Bricks.whateverplayer.Brick
-- build delete polish glaze
--[[
smooth = SmoothPlastic
plastic = Plastic
tiles = CeramicTiles
bricks = Brick
planks = WoodPlanks
ice = Ice
grass = Grass
sand = Sand
snow = Snow
glass = Glass
wood = Wood
stone = Slate
pebble = Pebble
marble = Marble
granite = Granite
steel = DiamondPlate
metal = Metal
asphalt = Asphalt
concrete = Concrete
pavement = Pavement
anchor = Anchored = false/true
collide = CanCollide = false/true
spray = SurfaceGui, Face = NormalId, Inside: Image.Image = blank if not exist, Label.Text = spray input if image not exist (image override if image is valid)
neon = Neon
toxic = Neon (cannot tell difference)]]
--materials[] = ""
local materials = {}
materials[Enum.Material.SmoothPlastic] = "smooth"
materials[Enum.Material.Plastic] = "plastic"
materials[Enum.Material.CeramicTiles] = "tiles"
materials[Enum.Material.Brick] = "bricks"
materials[Enum.Material.WoodPlanks] = "planks"
materials[Enum.Material.Ice] = "ice"
materials[Enum.Material.Grass] = "grass"
materials[Enum.Material.Sand] = "sand"
materials[Enum.Material.Snow] = "snow"
materials[Enum.Material.Glass] = "glass"
materials[Enum.Material.Wood] = "wood"
materials[Enum.Material.Slate] = "stone"
materials[Enum.Material.Pebble] = "pebble"
materials[Enum.Material.Marble] = "marble"
materials[Enum.Material.Granite] = "granite"
materials[Enum.Material.DiamondPlate] = "steel"
materials[Enum.Material.Metal] = "metal"
materials[Enum.Material.Asphalt] = "asphalt"
materials[Enum.Material.Concrete] = "concrete"
materials[Enum.Material.Pavement] = "pavement"
materials[Enum.Material.Neon] = "neon"
local swappedmaterials = {}
for i,v in pairs(materials) do
    swappedmaterials[v] = i
end
function saveblock(bl)
    local blockdata = {}
    if bl:IsA("BasePart") then
		local p = bl.Position
        blockdata.p = {bl.Position.X,bl.Position.Y,bl.Position.Z}
        blockdata.c = {math.round(bl.Color.R*255),math.round(bl.Color.G*255),math.round(bl.Color.B*255)}
        blockdata.a = bl.Anchored
		blockdata.cc = bl.CanCollide
        if bl.Size.X ~= mult or bl.Size.Y ~= mult or bl.Size.Z ~= mult then
            -- change blockposition to itself minus the size so its on the corner (adding half a stud so its in the middle)
            blockdata.p[1] = (blockdata.p[1] - (bl.Size.X/2))+.5
            blockdata.p[2] = (blockdata.p[2] - (bl.Size.Y/2))+.5
            blockdata.p[3] = (blockdata.p[3] - (bl.Size.Z/2))+.5
            --createpartpos(CFrame.new(table.unpack(blockdata.pos)),Color3.fromRGB(255,0,0))
            blockdata.s = {bl.Size.X,bl.Size.Y,bl.Size.Z}
        else
            --createpartpos(CFrame.new(table.unpack(blockdata.pos)),Color3.fromRGB(0,255,0))
        end
--[[
        if bl.Material == Enum.Material. then
            blockdata.mat = ""
        end
]]
		blockdata.m = materials[bl.Material]
		blockdata.o = bl.Material.Name
		-- no toxify because we cant tell the difference between neon and toxify :(
		blockdata.sp = {}
		for i,v in pairs(bl:GetChildren()) do
			if v.Name == "Spray" then
				table.insert(blockdata.sp,{v.Face.Name,v.Image.Image,string.gsub(v.Label.Text,'"','\"')}) -- No work! :(
			end
		end
    end
    return blockdata
end
lib.makebutton("Save Build",bsaltab,function()
    local builddata = {}
    for i,v in pairs(workspace.Bricks[localplr.Name]:GetChildren()) do
        if v:IsA("BasePart") then
            table.insert(builddata,saveblock(v))
        end
    end
    local savebuildname2 = savebuildname
    if savebuildname == "Untitled" or builds[savebuildname] ~= nil then
        if savebuildnames[savebuildname] == nil then
            savebuildnames[savebuildname] = 0
        end
        savebuildnames[savebuildname] = savebuildnames[savebuildname] + 1
        local savebuildamt = savebuildnames[savebuildname]
        savebuildname2 = savebuildname..tostring(savebuildamt)
    end
    builds[savebuildname2] = builddata
    updatedropdown()
end)
lib.makebutton("Save Server Builds",bsaltab,function()
    local builddata = {}
    for i,v in pairs(workspace.Bricks:GetDescendants()) do
        if v:IsA("BasePart") then
            table.insert(builddata,saveblock(v))
        end
    end
    local savebuildname2 = savebuildname
    if savebuildname == "Untitled" or builds[savebuildname] ~= nil then
        if savebuildnames[savebuildname] == nil then
            savebuildnames[savebuildname] = 0
        end
        savebuildnames[savebuildname] = savebuildnames[savebuildname] + 1
        local savebuildamt = savebuildnames[savebuildname]
        savebuildname2 = savebuildname..tostring(savebuildamt)
    end
    builds[savebuildname2] = builddata
    updatedropdown()
end)
local plrbuild = nil
local plrbuilds = {ServerBuilds = workspace.Bricks}
local plrnames = {"ServerBuilds"}
local hpb = true
local buildhighlight = Instance.new("Highlight")
buildhighlight.Parent = game.CoreGui
buildhighlight.FillColor = Color3.fromRGB(0,255,0)
buildhighlight.FillTransparency = .9
plrdropdown = lib.makedropdown("Select Player Builds",bsaltab,{},function(sel)
    plrbuild = plrbuilds[sel]
    buildhighlight.Adornee = plrbuild
end)
function upddd()
	table.sort(plrnames,function(a,b)
		return a:lower() < b:lower()
	end)
	lib.updatedropdown(plrdropdown,plrnames)
end
function dobricks(f,nud)
	plrbuilds[f.Name] = f
	if f:FindFirstChild("Brick") then
		table.insert(plrnames,f.Name)
	end
	table.insert(conn,f.ChildAdded:Connect(function(b)
		if not table.find(plrnames,f.Name) then
			table.insert(plrnames,f.Name)
			upddd()
		end
	end))
	table.insert(conn,f.ChildRemoved:Connect(function(b)
		if #f:GetChildren() <= 0 and table.find(plrnames,f.Name) then
			table.remove(plrnames,table.find(plrnames,f.Name))
			upddd()
		end
	end))
	if nud == nil then
		upddd()
	end
end
for i,v in pairs(workspace.Bricks:GetChildren()) do
	if v:IsA("Model") then
		dobricks(v,true)
	end
end
upddd()
local onbrick = workspace.Bricks.ChildAdded:Connect(function(child)
	dobricks(child)
end)
lib.maketoggle("Highlight Player Build",bsaltab,function()
	hpb = bool
	if not hpb then
		buildhighlight.FillTransparency = 1
		buildhighlight.OutlineTransparency = 1
	elseif hpb then
		buildhighlight.FillTransparency = .9
		buildhighlight.OutlineTransparency = 0
	end
end,true)
lib.makebutton("Save Player Build",bsaltab,function()
    local builddata = {}
    for i,v in pairs(plrbuild:GetChildren()) do
        if v:IsA("BasePart") then
            table.insert(builddata,saveblock(v))
        end
    end
    local savebuildname2 = savebuildname
    if savebuildname == "Untitled" or builds[savebuildname] ~= nil then
        if savebuildnames[savebuildname] == nil then
            savebuildnames[savebuildname] = 0
        end
        savebuildnames[savebuildname] = savebuildnames[savebuildname] + 1
        local savebuildamt = savebuildnames[savebuildname]
        savebuildname2 = savebuildname..tostring(savebuildamt)
    end
    builds[savebuildname2] = builddata
    updatedropdown()
end)

lib.makelabel("loading/deleting builds",bsaltab)
builddropdown = lib.makedropdown("Saved Builds",bsaltab,{},function(sel)
    selectedbuild = {sel,builds[sel]}
end)
local bindfunc = Instance.new("BindableFunction")
bindfunc.OnInvoke = function(prompt)
    if prompt == "Yes" and selectedbuild ~= nil then
        builds[selectedbuild[1]] = nil
        selectedbuild = nil
        updatedropdown()
    end
end
lib.makebutton("Delete Save",bsaltab,function()
    starterui:SetCore("SendNotification",{Title="Delete Save?",Text="Are you sure you want to delete the save?",Duration=5,Callback=bindfunc,Button1="Yes",Button2="No"})
end)
function getbuild()
    if selectedbuild then
        return selectedbuild[2]
    end
    return nil
end
local offset = Vector3.new(0,0,0)
lib.makebutton("Load Save",bsaltab,function()
    if selectedbuild ~= nil then
        local build = getbuild()
        if build then
			if oldprt then
				oldprt:Destroy()
			end
            for i,v in pairs(selectedbuild[2]) do
				if stopped == true then
					break
				end
                local blocktype = nil
                local args = {}
				local posses = (v.p or v.pos)
                args[1] = CFrame.new(posses[1],posses[2],posses[3]).Position + offset
				args[2] = v.m or v.mat
                args[3] = Color3.fromRGB(table.unpack(v.c or v.color))
                if v.s or v.size then
                    args[5] = Vector3.new(table.unpack(v.s or v.size))
                end
                createpartrepl(args[1],args[5],args[3],swappedmaterials[v.m or v.mat])
				args[7] = v.o or v.origmat
				args[8] = v.sp or v.sprayed
				args[9] = v.a or v.anchored
				args[10] = v.cc or v.collide
                buildblock(args[1],args[2],args[3],nil,args[5],nil,args[7],args[8],args[9],args[10])
            end
			stopped = false
        end
    end
end)
function optimizebuilds()
    if selectedbuild ~= nil then
        local build = getbuild()
        if build then
            for i,v in pairs(selectedbuild[2]) do
				local p = CFrame.new(table.unpack(v.pos)).Position
                v.pos = nil
				v.p = {p.X,p.Y,p.Z}
				v.m = v.mat
				v.mat = nil
				v.s = v.size or nil
				v.size = nil
				v.c = v.color
				v.color = nil
				v.o = v.origmat
				v.origmat = nil
				v.sp = v.sprayed
				v.sprayed = nil
				v.a = v.anchored
				v.anchored = nil
				v.cc = v.collide
				v.collide = nil
            end
			builds[selectedbuild[1]] = selectedbuild[2]
			updatedropdown()
        end
    end
end
lib.makelabel("extra settings/display build",bsaltab)
local offsetpart = Instance.new("Part")
offsetpart.Shape = Enum.PartType.Ball
offsetpart.Anchored = true
offsetpart.CanCollide = false
offsetpart.CastShadow = false
offsetpart.CanQuery = false
offsetpart.Color = Color3.new(0,1,0)
offsetpart.Transparency = 1
offsetpart.Size = Vector3.new(3,3,3)
offsetpart.CFrame = CFrame.new(0,0,0)
offsetpart.Parent = workspace
lib.makebutton("Offset Build",bsaltab,function()
	offset = round(workspace.Spawn.Position + game.Players.LocalPlayer.Character.HumanoidRootPart.Position)
	offsetpart.Position = offset
	offsetpart.Transparency = 0.5
end)
lib.makebutton("Reset Offset",bsaltab,function()
	offset = Vector3.new(0,0,0)
	offsetpart.Transparency = 1
end)
lib.makebutton("OPTIMIZE BUILD (if build is already optimized/saved after this update then it will error)",bsaltab,function()
	optimizebuilds()
end)
lib.makebutton("OPTIMIZE ALL BUILDS (RECOMMENDED)",bsaltab,function()
	local psb = selectedbuild
	for i,v in pairs(builds) do
		selectedbuild = {i,v}
		local s,e = pcall(optimizebuilds)
		if not s then print("Build Already Optimized! ("..selectedbuild[1]..") \n",e) end
	end
	selectedbuild = psb
end)
local prttable = nil
lib.makebutton("Display Whole Build (might lag, only you see)",bsaltab,function()
    if selectedbuild ~= nil then
        local build = getbuild()
        if build then
            if prttable then
                for i,v in pairs(prttable) do
                    v:Destroy()
                end
            end
            local laggyparttable = {}
            for i,v in pairs(selectedbuild[2]) do
                local blocktype = nil
                local args = {}
				local posses = (v.pos or v.p)
                args[1] = CFrame.new(posses[1],posses[2],posses[3]).Position + offset
				args[2] = v.mat or v.m
                args[3] = Color3.fromRGB(table.unpack(v.color or v.c))
                if v.size or v.s then
                    args[5] = Vector3.new(table.unpack(v.size or v.s))
                end
                local prt = createpartrepl(args[1],args[5],args[3],swappedmaterials[v.mat or v.m],0,v.anchored or v.a,v.collide or v.cc,v.sprayed or v.sp)
                table.insert(laggyparttable,prt)
            end
            prttable = laggyparttable
        end
    end
end)
lib.makebutton("Delete build display (might lag, only you see)",bsaltab,function()
    if prttable then
        for i,v in pairs(prttable) do
            v:Destroy()
        end
    end
end)
lib.makelabel("settings to make building faster",bsaltab)
lib.makelabel("The more brick history the more smooth the building will go, but if its too high it might lag",bsaltab)
lib.makelabel("Defaulted to 150",bsaltab)
lib.maketextbox("Brick History",bsaltab,function(txt)
    if tonumber(txt) then
        historymax = math.abs(tonumber(txt)) -- weirdoes setting it to negative numbers dont even think about it
        for i,v in pairs(cubehistory) do
            if i > historymax then
                cubehistory[i] = nil
            end
        end
    end
end)
lib.makelabel("if you have good wifi you should set the Wait before resizing lower",bsaltab)
lib.makelabel("defaulted to 0.4",bsaltab)
lib.makelabel("setting it too low may cause the script to not resize blocks properly",bsaltab)
local resizewaitlabel = nil
lib.maketextbox("Wait before resizing",bsaltab,function(txt)
    if tonumber(txt) then
        resizewait = tonumber(txt)
        lib.updatelabel("Resize Wait: "..tostring(resizewait),resizewaitlabel)
    end
end)
local lastwbs = resizewait
lib.maketoggle("Make wait before resizing based on ping",bsaltab,function(bool)
	wbs = bool
	if wbs then
		lastwbs = resizewait
	else
		resizewait = lastwbs
		lib.updatelabel("Resize Wait: "..tostring(resizewait),resizewaitlabel)
	end
end)
resizewaitlabel = lib.makelabel("Resize Wait: 0.4",bsaltab)
pinglabel = lib.makelabel("Ping: ???",bsaltab)
lib.makelabel("To make the auto resize wait work better turn on performance stats",bsaltab)
local ping = -100
coroutine.wrap(function()
    while ors do
		task.wait(1)
		if not wbs then continue end
		local newping = -199
		local s,e = pcall(function()
			for i,v in pairs(game:GetService("CoreGui").RobloxGui.PerformanceStats:GetChildren()) do
				if v:FindFirstChild("StatsMiniTextPanelClass") and v.StatsMiniTextPanelClass:FindFirstChild("TitleLabel") and v.StatsMiniTextPanelClass:FindFirstChild("ValueLabel") and v.StatsMiniTextPanelClass.TitleLabel.Text == "Ping" then
					newping = tonumber(string.sub(v.StatsMiniTextPanelClass.ValueLabel.Text,1,string.find(v.StatsMiniTextPanelClass.ValueLabel.Text," ms")-1))
				end
			end
		end)
		if not s then
			newping = localplr:GetNetworkPing()
		end
		if newping ~= ping then
			ping = newping
			historynum2 = historynum2 + 1
			if historynum2 > 5 then
				historynum2 = 1
			end
			local multi = 2.7
			if ping > 250 then
				multi = 2.5
			elseif ping > 500 then
				multi = 2.2
			end
			lib.updatelabel("Ping: "..tostring(ping),pinglabel)
			pinghistory[historynum2] = ping*multi -- added a little extra for fluctuations or whatever
			local allnums = 0
			for i,v in pairs(pinghistory) do
				allnums = allnums + v
			end
			resizewait = (allnums/#pinghistory)/1000
			lib.updatelabel("Resize Wait: "..tostring(resizewait),resizewaitlabel)
		end
	end
end)()
updatedropdown()
lib.makelabel("Pressing 'say' will not make you say to everyone, you say it privately",geartab)
lib.makelabel("Doing the say/copy will say/copy the gear id, not the gear name",geartab)
local currgears = {}
local chatgear = false
local gearcopybefore = "gear me "
lib.makebutton("Put gear id with 'gear me'",geartab,function()
    gearcopybefore = "gear me "
end)
lib.makebutton("Put gear id with 'gear all'",geartab,function()
    gearcopybefore = "gear all "
end)
lib.maketextbox("Put gear id with what you enter",geartab,function(txt)
	txt = string.gsub(txt,'"','\"')
    local len = string.len(txt)
    if len > 0 then
        if string.sub(txt,len,len) == " " then
            txt = string.sub(txt,1,len-1)
        end
        txt = txt.." "
    end
    gearcopybefore = txt
end)
local chat = nil
local s,e = pcall(function()
    chat = nil--require(game:GetService("Players").LocalPlayer:WaitForChild("PlayerScripts"):WaitForChild("ChatScript"):WaitForChild("ChatMain"))
end)
function say(text,channel)
    coroutine.wrap(function()
        --game:GetService("ReplicatedStorage"):WaitForChild("DefaultChatSystemChatEvents"):WaitForChild("SayMessageRequest"):FireServer(text,channel or "System")
        if channel and channel:lower() == "system" then
            if string.sub(text,1,1) ~= ";" then
                text = ";"..text
            end
            game:GetService("TextChatService").TextChannels.RBXSystem:SendAsync(text)
        else
            game:GetService("TextChatService").TextChannels.RBXGeneral:SendAsync(text)
        end
    end)()
end
local gsavenames = "tcogearsavenames.txt"
function savegears()
    local s,e = pcall(function()
        local tjson = game:GetService("HttpService"):JSONEncode(currgears)
        writefile(gsavenames,tjson)
    end)
end
function makegear(gearname,gearid,save,changename)
    deletegear(gearid)
    if changename == nil then
        changename = true
    end
    if changename then
    local foundcopy = false
    for i,v in pairs(currgears) do
        if v[3] == gearname then
            foundcopy = true
        end
    end
    if foundcopy then
        local n = 1
        local gearname2 = gearname
        repeat
            local foundcopy2 = false
            gearname2 = gearname.." "..tostring(n)
            for i,v in pairs(currgears) do
                if v[3] == gearname2 then
                    foundcopy2 = true
                end
            end
            n = n + 1
            if not foundcopy2 then
                foundcopy = false
            end
            task.wait()
        until foundcopy == false
        gearname = gearname2
    end
    end
    local gbutton = lib.makebutton("Copy "..gearname,geartab,function()
        setclipboard(gearcopybefore..tostring(gearid))
    end)
    local gbutton2 = lib.makebutton("Say "..gearname,geartab,function()
        say(gearcopybefore..tostring(gearid),"system")
    end)
    if save then
        currgears[gearid] = {gbutton,gbutton2,gearname,gearid}
        savegears()
    end
end
function deletegear(gearid)
    if currgears[gearid] then
        local v = currgears[gearid]
        local s,e = pcall(function()
            v[1]:Destroy()
            v[2]:Destroy()
            currgears[gearid] = nil
            savegears()
        end)
    end
end
lib.makelabel("Preset Gears",geartab)
makegear("Pot Of Gold",24015579,false)
makegear("Merely's Web Slinger",169602010,false)
makegear("Dagger of Shattered Dimensions",71037101,false)
makegear("Portable Justice (Blacklisted)",82357101,false)
makegear("BB-8",1183007014,false)
makegear("BB-9E",1183007628,false)
makegear("Advanced Paint Bucket",18474459,false)
makegear("Rainbow Periastron",159229806,false)
makegear("Chartreuse Periastron",80661504,false)
makegear("Crimson Periastron",99119240,false)
makegear("Azure Periastron",69499437,false)
makegear("Noir Periastron",120307951,false)
makegear("Ivory Periastron",108158379,false)
makegear("Grimgold Periastron",73829193,false)
makegear("Amethyst Periastron",93136802,false)
makegear("Festive Periastron",139577901,false)
makegear("Joyful Periastron",233520257,false)
makegear("Fall Periastron",2544549379,false)
makegear("Fake Chartreuse Periastron",80597060,false)
makegear("Blizzard Wand",68354832,false)
makegear("Poseidon's Quake Trident",54130559,false)
makegear("Classic Bucket",25162389,false)
makegear("Vampire Vanquisher",94794847,false)
makegear("Exploding Heart",178076989,false)
makegear("Portable Beach (R6)",162857357,false)
makegear("Scroll of Sevenless",125013830,false)
makegear("Positronic Platform Producer",34898883,false)
makegear("Azure Dragon's Magic Slayer",268586231,false)
makegear("Azure Mines Pickaxe",583030187,false)
makegear("Body Swap Potion",78730532,false)
makegear("Crossbow of the Sea",236438668,false)
lib.makelabel("Custom Gears (creation)",geartab)
local gnamesel = "Untitled"
lib.maketextbox("Enter gear name",geartab,function(txt)
	txt = string.gsub(txt,'"','\"')
    gnamesel = txt
end)
local gidsel = "0"
lib.maketextbox("Enter gear id",geartab,function(txt)
	txt = string.gsub(txt,'"','\"')
    gidsel = txt
end)
lib.makebutton("Create Gear Buttons",geartab,function()
    if currgears[gidsel] then
        deletegear(gidsel)
    end
    makegear(gnamesel,gidsel,true)
end)
lib.maketextbox("Delete Gear Buttons (enter in id)",geartab,function(txt)
    deletegear(txt)
end)
lib.makelabel("Custom Gears",geartab)
local s,e = pcall(function()
    currgears = game:GetService("HttpService"):JSONDecode(readfile(gsavenames))
    if currgears == nil then
        currgears = {}
    end
    for i,v in pairs(currgears) do
        makegear(v[3],i,true,false)
    end
    savegears()
end)
local spamming = nil
lib.maketoggle("Spam Equipped Tools",tooltab,function(bool)
    if bool then
        spamming = true
    else
        spamming = nil
    end
end)
local dee = false
lib.maketoggle("Don't equip enlighten when dropping/equipping tools",tooltab,function(bool)
    dee = bool
end)
lib.makebutton("Equip All Tools",tooltab,function()
	for i,v in pairs(localplr.Backpack:GetChildren()) do
		if v:IsA("Tool") then
		    if (dee and v.Name ~= "The Arkenstone") or not dee then
			    v.Parent = localplr.Character
			end
		end
	end
end)
lib.makelabel("warning",tooltab)
lib.makebutton("Drop All Tools",tooltab,function()
	for i,v in pairs(localplr.Backpack:GetChildren()) do
		if v:IsA("Tool") then
		    if (dee and v.Name ~= "The Arkenstone") or not dee then
			    v.Parent = localplr.Character
			end
		end
	end
	task.wait()
	for i,v in pairs(localplr.Character:GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = workspace
		end
	end
end)
lib.makelabel("warning",tooltab)
local dee2 = true
lib.maketoggle("Don't equip enlighten when dropping tools (For auto drop)",tooltab,function(bool)
    dee2 = bool
end,true)
local pickuptools = true
local autodroptools = true
local currhum = nil
function dc(c)
    local f = c.ChildAdded:Connect(function(child)
        if child:IsA("Humanoid") then
            currhum = child
        end
    end)
    if c:FindFirstChild("Humanoid") then
        currhum = c.Humanoid
    end
    coroutine.wrap(function()
        repeat task.wait(10) until c == nil or c.Parent == nil
        f:Disconnect()
    end)()
end
if localplr.Character then
    dc(localplr.Character)
end
local onchradded = localplr.CharacterAdded:Connect(function(c)
    dc(c)
end)
coroutine.wrap(function()
    repeat
        task.wait(.1)
        if currhum ~= nil and currhum.Parent ~= nil then
            if pickuptools and currhum.Health > 0 then
                for i,v in pairs(workspace:GetChildren()) do
                    if v:IsA("Tool") and v:FindFirstChild("Handle") then
                        currhum:EquipTool(v)
                        if v.Name == "The Arkenstone" and autoperm then
                            task.wait(.1)
                        end
                    end
                end
            end
            if autodroptools and currhum.Health <= 0 then
                for i,v in pairs(localplr.Backpack:GetChildren()) do
                    if ((dee2 and v.Name ~= "The Arkenstone") or not dee2) then
                        v.Parent = localplr.Character
                    end
                end
                for i,v in pairs(localplr.Character:GetChildren()) do
                    if v:IsA("Tool") and ((dee2 and v.Name ~= "The Arkenstone") or not dee2) then
                        v.Parent = workspace
                    end
                end
            end
        end
    until not on
end)()
lib.maketoggle("Auto Pickup Dropped Tools",tooltab,function(bool)
    pickuptools = bool
end,true)
lib.maketoggle("Auto Drop Tools On Death",tooltab,function(bool)
    autodroptools = bool
end,true)
local ot = false
local autoperm = true
local alwaysreset = false
local alwaysresetall = false
local commands = {}
local onrender = game:GetService("RunService").Heartbeat:Connect(function()
    if spamming and on then
        for i,v in pairs(localplr.Character:GetChildren()) do
            if v:IsA("Tool") then
                v:Activate()
            end
        end
    end
    local attemptreset = false
    if autoperm and localplr.Character and localplr.Character:FindFirstChild("The Arkenstone") then
        say("reset me","system")
        attemptreset = true
    elseif autoperm and localplr.Backpack:FindFirstChild("The Arkenstone") and localplr:GetAttribute("Arken") ~= true and localplr.Character then
        localplr.Backpack["The Arkenstone"].Parent = localplr.Character
        say("reset me","system")
        attemptreset = true
    end
    if alwaysreset then
        say("reset me","system")
    end
    if alwaysresetall then
        say("reset all","system")
    end
    if not attemptreset then
        for i,v in pairs(commands) do
            if v == true then
                say(i,"system")
            end
        end
    end
	if novel == true and localplr.Character and localplr.Character:FindFirstChild("HumanoidRootPart") then
		localplr.Character.HumanoidRootPart.Velocity = Vector3.new(0,0,0)
	end
end)
lib.maketoggle("Auto Permanent Enlighten",scripttab,function(bool)
    autoperm = bool
end,true)
lib.maketoggle("Spam reset",scripttab,function(bool)
    alwaysreset = bool
end)
lib.maketoggle("Spam reset all",scripttab,function(bool)
    alwaysresetall = bool
end)
lib.makelabel("Since the chosen one updated to the new roblox chat, the no chat logger no longer works, use the 'clear chat logs' thing.",scripttab)
function clearclogs(amt)
    for i=1,amt do
        coroutine.wrap(function()
            say(";","system")
        end)()
    end
end
lib.makelabel("The clear chat of logs makes it so that if someone reports you, roblox will look into your first 10-15 chats (which will be cleared) and u wont get banned",scripttab)
lib.makelabel("(however, you have to manually clear it and you cant chat for a few seconds)",scripttab)
lib.makelabel("clear chat log by vxsty",scripttab)
lib.makebutton("Clear chat of logs (10)",scripttab,function()
    clearclogs(10)
end)
lib.makebutton("Clear chat of logs (20)",scripttab,function()
    clearclogs(20)
end)
local ccol = false
lib.maketoggle("Always clear chat of logs (RECOMMENDED, COMMANDS WONT WORK WHEN ENABLED)",scripttab,function(bool)
    ccol = bool
    while ccol do
        task.wait()
        clearclogs(5)
    end
end)
local threeemdash = "\u{2E3B}"
lib.maketextbox("Say Long Message (broken D:)",scripttab,function(input)
    if input == "" or input == nil then
        input = "200"
    end
    input = tonumber(input)
    say(string.rep(threeemdash,input),"All")
end)
lib.makelabel("warning",scripttab)
lib.makebutton("Execute Fling All Script",scripttab,function()
    if loadfile ~= nil and writefile ~= nil and readfile ~= nil then
        local cache = nil
        local success,err = pcall(function()
            cache = readfile("CachedFlingAll.txt")
        end)
        if not cache then
            cache = game:HttpGet("https://rawscripts.net/raw/Universal-Script-FLING-ALL-SCRIPT-17590")
            writefile("CachedFlingAll.txt",cache)
        end
        loadstring(cache)()
    else
        loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-FLING-ALL-SCRIPT-17590"))()
    end
end)
lib.makelabel("warning",scripttab)
lib.makebutton("Join VC Server",scripttab,function()
    game:GetService("TeleportService"):Teleport(12943247001,localplr)
end)
lib.makelabel("warning",scripttab)
local dbut = nil
dbut = lib.makebutton("Execute Zte Hub (HAS SILENT COMMAND LOGGER!)",scripttab,function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/khanh-lol/Ztehub/refs/heads/main/zte"))() 
    dbut:Destroy()
end)
local savefile = "tcospamcommandssave.txt"
local spamtxtssave = {}
local spamtxtinstance = {}
local spamnum = 0
local truncatetxt = true
local spamcmd = true
function addcmd(txt,save,index,start)
    local spamtxt = false
    if not index then
        if #spamtxtssave > 0 then
            for i,v in pairs(spamtxtssave) do
                if spamtxtssave[i+1] == nil then
                    index = i+1
                    break
                end
            end
        else
            index = 1
        end
    end
    spamnum = index
    local num = spamnum
    if save then
        spamtxtssave[spamnum] = txt
        --spamtxtssave["max"] = spamnum
    end
    local previewcmd = string.split(txt," ")[1]
    if not truncatetxt then
        previewcmd = txt
    end
    local tog = nil
    if spamcmd then
        commands[txt] = start or false
        tog = lib.maketoggle("Spam Command/Text ("..previewcmd.." "..tostring(num)..")",commandtab,function(bool)
            commands[txt] = bool
        end,start or nil)
    else
        commands[txt] = false
        tog = lib.makebutton("Say Command/Text ("..previewcmd.." "..tostring(num)..")",commandtab,function()
            if not attemptreset then
                say(txt,"system")
            end
        end)
    end
    spamtxtinstance[spamnum] = {tog,txt}
    if save then
        writefile(savefile,http:JSONEncode(spamtxtssave))
    end
    for i,v in pairs(spamtxtinstance) do
        v[1].LayoutOrder = i
    end
end
lib.maketoggle("Truncate/Shorten Text",commandtab,function(bool)
    truncatetxt = bool
    for i,v in pairs(spamtxtinstance) do
        v[1]:Destroy()
        --spamtxtinstance[i] = nil
    end
    for i,v in pairs(spamtxtssave) do
        i = tonumber(i)
        addcmd(v,false,i,commands[v])
    end
end,true)
lib.maketoggle("Spam Commands",commandtab,function(bool)
    spamcmd = bool
    for i,v in pairs(spamtxtinstance) do
        v[1]:Destroy()
        --spamtxtinstance[i] = nil
    end
    for i,v in pairs(spamtxtssave) do
        i = tonumber(i)
        addcmd(v,false,i,commands[v])
    end
end,true)
lib.maketextbox("Enter Command",commandtab,function(txt)
	txt = string.gsub(txt,'"','\"')
    addcmd(txt,true)
end)
lib.maketextbox("Remove Command (put exact command)",commandtab,function(txt)
    for i,v in pairs(spamtxtssave) do
        if v == txt then
            spamtxtssave[i] = nil
        end
    end
    commands[txt] = false
    for i,v in pairs(spamtxtinstance) do
        if v[2] == txt then
            v[1]:Destroy()
        end
    end
    writefile(savefile,http:JSONEncode(spamtxtssave))
end)
local bindfunc = Instance.new("BindableFunction")
bindfunc.OnInvoke = function(prompt)
    if prompt == "Yes" then
        for i,v in pairs(spamtxtinstance) do
            v[1]:Destroy()
            spamtxtinstance[i] = nil
        end
        commands = {}
        spamtxtssave = {}
        writefile(savefile,http:JSONEncode(spamtxtssave))
    end
end
lib.makebutton("Reset All Commands",commandtab,function()
    starterui:SetCore("SendNotification",{Title="Delete Commands?",Text="Are you sure you want to reset the commands?",Duration=5,Callback=bindfunc,Button1="Yes",Button2="No"})
end)
lib.makelabel("",commandtab)
local s,e = pcall(function()
    local save = readfile(savefile)
    if save then
        spamtxtssave = http:JSONDecode(save) or {}
        for i,v in pairs(spamtxtssave) do
            i = tonumber(i)
            addcmd(v,false,i)
            --elseif i == "max" then
                --spamnum = v
        end
    end
end)
local blocktxt = lib.makelabel("No Block Selected",modtab)
lib.maketoggle("Outline Selected Block",modtab,function(bool)
	osb = bool
	if osb then
		sbox.LineThickness = 0.05
	else
		sbox.LineThickness = -1
	end
end)
lib.makelabel("",modtab)
local bboxtxt = lib.makelabel("No Boombox Selected",modtab)
local bbid = ""
lib.makebutton("Copy Boombox Sound ID",modtab,function()
	setclipboard(bbid)
end)
local osbb = false
lib.maketoggle("Outline Selected Boombox",modtab,function(bool)
	osbb = bool
	if osbb then
		bbsbox.LineThickness = 0.1
	else
		bbsbox.LineThickness = -1
	end
end)
local boomboxnames = {}
boomboxnames["SuperFlyGoldBoombox"] = true
boomboxnames["BoomboxGearThree"] = true
boomboxnames["DualGoldenSuperFlyBoombox"] = true
boomboxnames["DubstepBoombox"] = true
boomboxnames["BeatUpBoombox"] = true
inputbegan = game:GetService("UserInputService").InputBegan:Connect(function(input)
    if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) then
		local mousepart = mouse.Target
		if mousepart then
			if mousepart:IsDescendantOf(workspace.Bricks) then
				local plr = game.Players:FindFirstChild(mousepart.Parent.Name)
				local plrtxt = ""
				if plr then
					if plr.DisplayName == plr.Name then
						plrtxt = plr.Name
					else
						plrtxt = plr.DisplayName.."/"..plr.Name
					end
				else
					plrtxt = mousepart.Parent.Name.." (NOT INGAME)"
				end
				if mousepart.Parent.Parent == workspace then
					plrtxt = "Server Build (Not from anyone)"
				end
				lib.updatelabel("Block is from: "..plrtxt,blocktxt)
				if oss then
    				lib.updatelabel("Block is from: "..plrtxt,blocktxt2)
    				ssbox.Adornee = mousepart
    				ssbox.Face = side
    				sblock = mousepart
    	        end
    	        if ss then
        	        local ctm = nil
        	        for i,v in pairs(normalids) do
        	            local pos = mousepart.Position + (v[1]*mousepart.Size[v[2]]/2)
        	            if ctm == nil then
        	                ctm = {i,(mouse.Hit.Position - pos).Magnitude}
        	            elseif (mouse.Hit.Position - pos).Magnitude < ctm[2] then
        	                ctm = {i,(mouse.Hit.Position - pos).Magnitude}
        	            end
        	        end
        	        side = ctm[1]
        	        ssbox.Face = side
        	    end
			else
				lib.updatelabel("No Block Selected",blocktxt)
				sbox.Adornee = nil
			end
			if boomboxnames[mousepart.Parent.Name] == true then
				local sound = mousepart.Parent:FindFirstChild("Sound",true)
				if sound.SoundId == nil or sound.SoundId == "" then
					lib.updatelabel("No sound is playing on the boombox!",bboxtxt)
					bbid = ""
				else
					bbid = string.sub(sound.SoundId,string.find(sound.SoundId,"id=")+3)
					lib.updatelabel("Boombox ID: "..bbid,bboxtxt)
				end
				bbsbox.Adornee = mousepart.Parent.Handle
			else
				lib.updatelabel("No Boombox Selected",bboxtxt)
				bbsbox.Adornee = nil
			end
		else
			lib.updatelabel("No Block Selected",blocktxt)
			sbox.Adornee = nil
			lib.updatelabel("No Boombox Selected",bboxtxt)
			bbsbox.Adornee = nil
		end
	end
end)
local groups = {}
groups[5345749] = {"Chosen One Enthusiasts Club",Color3.fromRGB(0,255,0)}
groups[35956339] = {"Clementiuilo",Color3.fromRGB(108,77,59)}
groups[33203248] = {"Roblox's Rejects",Color3.fromRGB(177,125,82)}
groups[35155850] = {"Unchainable Mercy",Color3.fromRGB(108,77,59)}
groups[35985581] = {"Genesis",Color3.fromRGB(82,138,174)}
groups[33258647] = {"Union of Mirrland Communist States",Color3.fromRGB(120,0,0)}
groups[34915496] = {"dauens silly",{0,120,0}}
groups[34348476] = {"Frigid's silly fan club",Color3.fromRGB(0,0,200)}
groups[34838919] = {"Cult Of Combat",Color3.fromRGB(255,0,0)}
groups[34838919] = {"The Eternal Flame of TCO",Color3.fromRGB(255,255,0)}
groups[35986983] = {"Realm ???",Color3.fromRGB(42,73,199)}
local dheads = {}
function plradded(plr)
	local owner = scrowners[plr.UserId]
    local nahhh = plr.Name == "Visible_Threat"
    local beggar = plr.Name == "Skibisaacjacob" or plr.Name == "spiralrblxofficial"
	local group = false
	for i,v in pairs(groups) do
		if plr:IsInGroup(i) then
			local nv = v
			table.insert(v,i)
			group = nv
		end
	end
	if owner or group or nahhh or beggar then
		function onchar(c)
			coroutine.wrap(function()
				c:WaitForChild("Head",math.huge)
				local bbgui = Instance.new("BillboardGui")
				dheads[c.Head] = bbgui
				bbgui.Size = UDim2.new(10,0,1.5,0)
				bbgui.StudsOffset = Vector3.new(0,3.5,0)
				bbgui.Parent = c.Head
				local txt = Instance.new("TextLabel")
				txt.TextScaled = true
				txt.BackgroundTransparency = 1
				txt.Size = UDim2.new(1,0,1,0)
				txt.Position = UDim2.new(0,0,-0.5,0)
				txt.TextStrokeTransparency = 0
				local infotxt = Instance.new("TextLabel")
				infotxt.TextScaled = true
				infotxt.BackgroundTransparency = 1
				infotxt.Size = UDim2.new(1,0,0.5,0)
				infotxt.Position = UDim2.new(0,0,0.5,0)
				infotxt.TextStrokeTransparency = 0
				if owner then
					txt.Text = "Script Owner (Extra Stuff)"
					infotxt.Text = "Don't ask me for the 'tag' script, you only see this when you execute the script."
					txt.TextColor3 = Color3.fromRGB(200,90,0)
				elseif beggar then
					txt.Text = "Beggar"
					infotxt.Text = "laugh at this person please"
					txt.TextColor3 = Color3.fromRGB(0,100,0)
				elseif nahhh then
					txt.Text = "I'm Not Tuff"
					infotxt.Text = "stop using my script, you are not tuff!"
					txt.TextColor3 = Color3.fromRGB(255,0,0)
				elseif group then
					txt.Text = group[1]
					txt.TextColor3 = group[2]
					infotxt.Text = plr:GetRoleInGroup(group[3])
				end
				txt.Parent = bbgui
				infotxt.TextColor3 = txt.TextColor3
				infotxt.Parent = bbgui
			end)()
		end
		if plr.Character then
			onchar(plr.Character)
		end
		table.insert(conn,plr.CharacterAdded:Connect(onchar))
	end
end
for i,v in pairs(game.Players:GetPlayers()) do
	plradded(v)
end
local onplr = game.Players.PlayerAdded:Connect(plradded)
lib.ondestroyedfunc = function()
    on = false
    ot = false
    ccol = false
    stopped = true
    skipblock = true
    autoperm = false
    alwaysreset = false
    alwaysresetall = false
    built = true
	cubechild:Disconnect()
	onrender:Disconnect()
	inputbegan:Disconnect()
    highlight:Destroy()
	onplr:Disconnect()
    daura = false
    dauras = false
    ors = false
    daurapart:Destroy()
    for i,v in pairs(commands) do
        v = false
    end
    pickuptools = false
    autodroptools = false
    onchradded:Disconnect()
    dee2 = false
    dee = false
    spmbl = false
    spmsi = false
    if prttable then
        for i,v in pairs(prttable) do
            v:Destroy()
        end
    end
    --writefile(savefile,http:JSONEncode(spamtxtssave))
	wbs = false
	if oldprt then
	    oldprt:Destroy()
	end
	sbox.Adornee = nil
	sbox:Destroy()
	bbsbox.Adornee = nil
	bbsbox:Destroy()
	for i,v in pairs(conn) do
		v:Disconnect()
	end
	for i,v in pairs(dheads) do
		if v then
			v:Destroy()
		end
	end
	ssbox.Adornee = nil
	ssbox:Destroy()
	spmsb = false
	ss = false
	tp = false
	onbrick:Disconnect()
	buildhighlight:Destroy()
	offsetpart:Destroy()
end
end)
if not success then print(err) end
   end,
})

